<!DOCTYPE html>
<html lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="description" content="低调做人，高调做事。">


    <meta name="keywords" content="技术博客/Android/Linux">


<title>一张图带你深入了解Handler机制 | KCrason&#39;s Blog</title>



    <link rel="icon" href="/favicon.ico">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    



    
    
        
    


</head>
<body>
    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">KCrason&#39;s Blog</a></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/categories">Categories</a>
                
                    <a class="menu-item" href="/tags">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>

        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">KCrason&#39;s Blog</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/categories">Categories</a>
                
                    <a class="menu-item" href="/tags">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
        <div class="main">
            <div class="container">
    
    
        <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">Expand all</a>
        <a onclick="go_top()">Back to top</a>
        <a onclick="go_bottom()">Go to bottom</a>
    </div>
</div>

<script>
    document.ready(
        function () {
            tocbot.init({
                tocSelector: '.tocbot-list',
                contentSelector: '.post-content',
                headingSelector: 'h1, h2, h3, h4, h5',
                collapseDepth: 1,
                orderedList: false,
                scrollSmooth: true,
            })
        }
    )

    function expand_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 6,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "collapse_toc()");
        b.innerHTML = "Collapse all"
    }

    function collapse_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 1,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "expand_toc()");
        b.innerHTML = "Expand all"
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

</script>
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">一张图带你深入了解Handler机制</h1>
            
                <div class="post-meta">
                    
                        Author: <a itemprop="author" rel="author" href="/">KCrason</a>
                    

                    
                        <span class="post-time">
                        Date: <a href="#">December 6, 2017&nbsp;&nbsp;12:45:15</a>
                        </span>
                    
                    
                        <span class="post-category">
                    Category:
                            
                                <a href="/categories/Android/">Android</a>
                            
                        </span>
                    
                </div>
            
        </header>

        <div class="post-content">
            <h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><hr>
<p>这两天正好闲着，遂回顾了一下以前觉得理解的很模糊的东西。Handler机制便是其中之一。<br>尽管我们经常用Handler进行线程之间的通信。但是对其中的过程，可能没太怎么去了解。即便有了解，可能也被复杂的逻辑给整蒙了。又是<code>Looper</code>又是<code>MessageQueue</code>的。我就是被整蒙圈的一员。但是今天，我将它重新梳理了一遍，在此记录一下。一方面是便于以后查看，另一方面加深自己的理解。</p>
<h4 id="Handler机制思维导图"><a href="#Handler机制思维导图" class="headerlink" title="Handler机制思维导图"></a>Handler机制思维导图</h4><hr>
<p>先上一张我画的思维导图，通过这张图，你就能清晰明了的了解<code>Handler</code>，<code>Looper</code>、<code>Message</code>、<code>MessageQueue</code>它们之间的千丝袜缕了。</p>
<blockquote>
<p>该图比较大，建议在电脑上观看效果会更好。<a href="https://github.com/KCrason/kcrason.github.io/blob/master/uploads/images/Handler%E6%9C%BA%E5%88%B6.png" target="_blank" rel="noopener">https://github.com/KCrason/kcrason.github.io/blob/master/uploads/images/Handler%E6%9C%BA%E5%88%B6.png</a></p>
</blockquote>
<p><img src="http://upload-images.jianshu.io/upload_images/1860505-368050adf39e1543.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Handler机制.png"></p>
<h4 id="Handler机制流程分析"><a href="#Handler机制流程分析" class="headerlink" title="Handler机制流程分析"></a>Handler机制流程分析</h4><hr>
<h5 id="流程概述"><a href="#流程概述" class="headerlink" title="流程概述"></a>流程概述</h5><p>首先，我们知道，通常在<code>Android Activity</code>中使用<code>Handler</code>的流程是：创建<code>Handler</code>对象-&gt;在异步线程中使用<code>Handler</code>对象发送消息。然后就能在<code>Handler</code>的回调中收到消息。而事实上<code>Handler</code>机制的起始并不是从创建<code>Handler</code>对象开始，而是从<code>Looper.preare()</code>开始的。之后还要调用<code>Looper.loop()</code>整个过程才算真正完成。在<code>Activity</code>之所以看不到<code>Looper</code>相关的代码，是因为主线程已经做了。<code>ActivityThread</code>(主线程)的main方法源码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">        SamplingProfilerIntegration.start();  </span><br><span class="line"></span><br><span class="line">        ...省略部分代码</span><br><span class="line">  </span><br><span class="line">        <span class="comment">//初始化Looper</span></span><br><span class="line">        Looper.prepareMainLooper();  </span><br><span class="line">  </span><br><span class="line">        ActivityThread thread = <span class="keyword">new</span> ActivityThread();  </span><br><span class="line">        thread.attach(<span class="keyword">false</span>);  </span><br><span class="line"></span><br><span class="line">        ...省略部分代码 </span><br><span class="line">        Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);  </span><br><span class="line"></span><br><span class="line">        <span class="comment">//开始循环取消息</span></span><br><span class="line">        Looper.loop();  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Main thread loop unexpectedly exited"</span>);  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>而你在异步线程中使用Handler，它应该是下面这样的逻辑：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">new Thread(new Runnable() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void run() &#123;</span><br><span class="line">                    //初始化Looper</span><br><span class="line">                    Looper.prepare();</span><br><span class="line">                    //创建Handler对象</span><br><span class="line">                    Handler handler = new Handler(new Handler.Callback() &#123;</span><br><span class="line">                        @Override</span><br><span class="line">                        public boolean handleMessage(Message msg) &#123;</span><br><span class="line">                            return false;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                    //开始循环取消息</span><br><span class="line">                    Looper.loop();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br></pre></td></tr></table></figure>

<p>知道了使用规则，那么下面我们根据这个规则来分析它们之前的联系。</p>
<h5 id="初始化Looper"><a href="#初始化Looper" class="headerlink" title="初始化Looper"></a>初始化Looper</h5><p>调用<code>Looper.preare()或Looper.prepareMainLooper</code>方法开始，就是创建<code>Looper</code>对象的起点。那么在<code>Looper.preare()</code>中到底干了啥呢。我们看源码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public static void prepare() &#123;</span><br><span class="line">     prepare(true);</span><br><span class="line">&#125;</span><br><span class="line">//quitAllowed是否允许终止循环取消息。</span><br><span class="line">private static void prepare(boolean quitAllowed) &#123;</span><br><span class="line">     if (sThreadLocal.get() != null) &#123;</span><br><span class="line">         throw new RuntimeException(&quot;Only one Looper may be created per thread&quot;);</span><br><span class="line">     &#125;</span><br><span class="line">     sThreadLocal.set(new Looper(quitAllowed));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，很简单，就是 <code>new</code>了一个<code>Looper</code>。然后将Looper对象设置进<code>sThreadLocal</code>。<code>sThreadLocal</code>是<code>Looper</code>类的一个常量对象，其在在<code>Looper</code>类中的声明：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">static final ThreadLocal&lt;Looper&gt; sThreadLocal = new ThreadLocal&lt;Looper&gt;();</span><br></pre></td></tr></table></figure>

<p>我们接着看<code>Looper</code>的构造函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">private Looper(boolean quitAllowed) &#123;</span><br><span class="line">   //创建一个MessageQueue赋值给mQueue </span><br><span class="line">   mQueue = new MessageQueue(quitAllowed);</span><br><span class="line">   //获取当前线程赋值给mThread </span><br><span class="line">   mThread = Thread.currentThread();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此，<code>Looper</code>的初始化工作完成。</p>
<h5 id="神奇的ThreadLocal"><a href="#神奇的ThreadLocal" class="headerlink" title="神奇的ThreadLocal"></a>神奇的ThreadLocal</h5><p>之所以说<code>ThreadLocal</code>很神奇，是因为它确实很神(好像是废话~)，它的神奇之处在于同一个<code>ThreadLocal</code>对象它可以在不同的线程间的赋值互不影响。什么意思呢？例子说明：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">private void testTreadLocal() &#123;</span><br><span class="line">        //创建ThreadLocal对象</span><br><span class="line">        final ThreadLocal&lt;String&gt; threadLocal = new ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        Thread oneThread = new Thread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                //oneThread设置值OneThreadValue</span><br><span class="line">                threadLocal.set(&quot;OneThreadValue&quot;);</span><br><span class="line">                //打印oneThread下的结果</span><br><span class="line">                Log.i(&quot;KCrason&quot;, &quot;testTreadLocal: &quot; + threadLocal.get());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Thread twoThread = new Thread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                //twoThread设置值TwoThreadValue</span><br><span class="line">                threadLocal.set(&quot;TwoThreadValue&quot;);</span><br><span class="line">                //打印twoThread下结果</span><br><span class="line">                Log.i(&quot;KCrason&quot;, &quot;testTreadLocal: &quot; + threadLocal.get());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        oneThread.start();</span><br><span class="line">        twoThread.start();</span><br><span class="line"></span><br><span class="line">        //主线程中设置值MainThreadValue</span><br><span class="line">        threadLocal.set(&quot;MainThreadValue&quot;);</span><br><span class="line"></span><br><span class="line">        //打印mainThread下结果</span><br><span class="line">        Log.i(&quot;KCrason&quot;, &quot;testTreadLocal: &quot; + threadLocal.get());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：<img src="http://upload-images.jianshu.io/upload_images/1860505-a82543446004e9fe.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="ThreadLocal测试结果"><br>通过输出结果，我们知道，其实<code>ThreadLocal</code>就是对不同线程的赋值拷贝了一个副本进而保存了。到此，我相信对于<code>ThreadLocal</code>，你已经能够理解了，至于它具体是如何实现的，这里暂不分析，你也可以去查看源码进行深入了解。</p>
<h5 id="Handler的创建"><a href="#Handler的创建" class="headerlink" title="Handler的创建"></a>Handler的创建</h5><p>同<code>Looper</code>一样，我们来照样从构造函数开始分析<code>Handler</code>的创建，看它到底干了啥？首先，Handler有多个构造函数，但它们无一例外的都会回到下面两个构造函数中来。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public Handler(Callback callback, boolean async) &#123;</span><br><span class="line">        ...省略部分代码</span><br><span class="line">        mLooper = Looper.myLooper();</span><br><span class="line">        if (mLooper == null) &#123;</span><br><span class="line">            throw new RuntimeException(</span><br><span class="line">                &quot;Can&apos;t create handler inside thread that has not called Looper.prepare()&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        mQueue = mLooper.mQueue;</span><br><span class="line">        mCallback = callback;</span><br><span class="line">        mAsynchronous = async;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public Handler(Looper looper, Callback callback, boolean async) &#123;</span><br><span class="line">        mLooper = looper;</span><br><span class="line">        mQueue = looper.mQueue;</span><br><span class="line">        mCallback = callback;</span><br><span class="line">        mAsynchronous = async;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>事实上，通过比较，我们发现他们俩干的事其实都是一样的。那都干啥了呢，分为两种情况：</p>
<p><strong>1、如果有传递<code>Looper</code>，那么直接将传递的<code>Looper</code>对象赋值给<code>mLooper</code>。</strong><br><strong>2、如果没有传递<code>Looper</code>，则通过<code>Looper.myLooper()</code>获取<code>Looper</code>对象。然后赋值给<code>mLooper</code>。</strong></p>
<p>前面我们提到初始化<code>Looper</code>时会将创建的<code>Looper</code>对象保存在<code>Looper</code>的<code>sThreadLocal</code>中，而<code>Looper.myLooper()</code>正是通过<code>sThreadLocal</code>去获取了在该线程下的<code>Looper</code>对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Looper中的myLooper方法源码</span><br><span class="line">public static @Nullable Looper myLooper() &#123;</span><br><span class="line">   //通过sThreadLocal的get()返回创建的Looper对象。</span><br><span class="line">   return sThreadLocal.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与此同时，通过获取到的<code>mLooper</code> 对象去获取在<code>Looper</code>中创建的<code>MessageQueue</code>对象并赋值给Handler的变量<code>mQueue</code>，最后将<code>Callback</code>对象进行赋值。<code>Handler</code>的初始化完成。</p>
<h5 id="Looper-loop-开启循环获取消息"><a href="#Looper-loop-开启循环获取消息" class="headerlink" title="Looper.loop()开启循环获取消息"></a>Looper.loop()开启循环获取消息</h5><p>事实上，在初始化<code>Looper</code>之后，就可以直接调用<code>Looper.loop()</code>进行循环取消息进行处理。只不过那时<code>MessageQueue</code>中还没有消息，循环就处于<code>block</code>状态罢了。我们看<code>loop()</code>方法源码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public static void loop() &#123;</span><br><span class="line">        final Looper me = myLooper();</span><br><span class="line">        if (me == null) &#123;</span><br><span class="line">            throw new RuntimeException(&quot;No Looper; Looper.prepare() wasn&apos;t called on this thread.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        final MessageQueue queue = me.mQueue;</span><br><span class="line"></span><br><span class="line">        ...省略部分代码</span><br><span class="line"></span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            Message msg = queue.next(); // might block</span><br><span class="line">            if (msg == null) &#123;</span><br><span class="line">                // No message indicates that the message queue is quitting.</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            ...省略部分代码</span><br><span class="line">        try &#123;</span><br><span class="line">                msg.target.dispatchMessage(msg);</span><br><span class="line">                end = (slowDispatchThresholdMs == 0) ? 0 : SystemClock.uptimeMillis();</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                if (traceTag != 0) &#123;</span><br><span class="line">                    Trace.traceEnd(traceTag);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ...省略部分代码</span><br><span class="line">            msg.recycleUnchecked();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>其流程简单来讲，就是通过一个死循环使用<code>MessageQueue</code>的<code>next()</code>方法不断的从<code>MessageQueue</code>中取出消息，如果为<code>null</code>，则<code>block</code>。否则，通过<code>msg.target.dispatchMessage(msg)</code>将消息分发。你可能会有所疑问，<code>msg.target</code>又是个什么鬼？没关系，我们接着往下分析。</p>
<h5 id="使用Handler发送消息"><a href="#使用Handler发送消息" class="headerlink" title="使用Handler发送消息"></a>使用Handler发送消息</h5><p>首先，在使用<code>Handler</code>发送消息时，不管是哪种方式，最终都会调用<code>sendMessageAtTime()</code>方法，其中<code>mHandler.post(Runnable runnable)</code>也是先将<code>runnable</code>封装成一个<code>Message</code>最后调用<code>sendMessageAtTime()</code>，根据源码分析：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//将runable封装到Message中</span><br><span class="line">private static Message getPostMessage(Runnable r) &#123;</span><br><span class="line">        Message m = Message.obtain();</span><br><span class="line">        //将Runnable对象r赋值给Message的callback变量。</span><br><span class="line">        m.callback = r;</span><br><span class="line">        return m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//发送消息</span><br><span class="line">public boolean sendMessageAtTime(Message msg, long uptimeMillis) &#123;</span><br><span class="line">        MessageQueue queue = mQueue;</span><br><span class="line">        if (queue == null) &#123;</span><br><span class="line">            RuntimeException e = new RuntimeException(</span><br><span class="line">                    this + &quot; sendMessageAtTime() called with no mQueue&quot;);</span><br><span class="line">            Log.w(&quot;Looper&quot;, e.getMessage(), e);</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        return enqueueMessage(queue, msg, uptimeMillis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>sendMessageAtTime()</code>中，我们注意到，其最后调用了<code>enqueueMessage()</code>，下面我们看<code>enqueueMessage()</code>又干了什么。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) &#123;</span><br><span class="line">        //将Handler对象赋值给msg.target</span><br><span class="line">        msg.target = this;</span><br><span class="line">        if (mAsynchronous) &#123;</span><br><span class="line">            msg.setAsynchronous(true);</span><br><span class="line">        &#125;</span><br><span class="line">        //将消息加入到MessageQueue(消息队列)</span><br><span class="line">        return queue.enqueueMessage(msg, uptimeMillis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从<code>enqueueMessage()</code>中，我们知道了上面那个<code>msg.target</code>是个啥了，它其实就是当前的<code>Handler</code>对象。<code>queue.enqueueMessage()</code>即真正意义上的将Message加入到消息队列中。最后通过<code>Handler</code>对象的<code>dispatchMessage()</code>方法，最终将消息回调出来。最后我们再看看<code>dispatchMessage()</code>中干了啥：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public void dispatchMessage(Message msg) &#123;</span><br><span class="line">        if (msg.callback != null) &#123;</span><br><span class="line">            handleCallback(msg);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            if (mCallback != null) &#123;</span><br><span class="line">                if (mCallback.handleMessage(msg)) &#123;</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            handleMessage(msg);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>显示判断<code>msg.callback</code>是否为<code>null</code>，而<code>msg.callback</code>实际上就是使用<code>mHandler.post(Runnable r)</code>发送的<code>Runnable</code>的对象。</p>
<p><strong>1、如果<code>msg.callback</code>不为<code>null</code>，调用<code>handleCallback</code>，而<code>handleCallback</code>就是调用了<code>msg.callback.run()</code></strong></p>
<p><strong>2、如果<code>msg.callback</code>为<code>null</code>，再判断是否设置了<code>Callback</code>接口，设置了回调<code>Callback</code>接口中的<code>handleMessage()</code>，没有设置直接回调<code>Handler</code>的空方法<code>handleMessage()</code>。</strong></p>
<p>至此，整个流程结束。</p>
<h4 id="一些疑问"><a href="#一些疑问" class="headerlink" title="一些疑问"></a>一些疑问</h4><p>尽管，通过上面的分析，我相信你对<code>Handler</code>的机制已经有了更深的理解。但是一直以来，有两个问题依然深深的困扰着我。</p>
<p>1、<code>Handler</code>究竟是如何进行不同线程切换的？</p>
<p>上面我们提到，通常而言，我们会使用<code>Handler</code>在异步线程中发送消息，之后都会调用<code>enqueueMessage()</code>方法将消息加入到消息队列中，而我们所使用的<code>MessageQueue</code>对象却是来源<code>MainThread(主线程)</code>中<code>Looper</code>所创建的。也就是说，<code>Handler</code>发送消息时，<code>MessageQueue</code>的对象是运行在异步线程中的。而使用Looper.loop()开启循环后，<code>MessageQueue</code>的对象是运行在<code>MainThread(主线程)</code>的。这也是为什么在<code>enqueueMessage()</code>中，将消息加入到消息队列需要增加<code>synchronized</code>关键字，因为我们需要确保<code>MessageQueue</code>对象在同一时刻只能有一个线程访问。这一点，在<code>MessageQueue#enqueueMessage()</code>的源码得到验证：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">boolean enqueueMessage(Message msg, long when) &#123;</span><br><span class="line">        if (msg.target == null) &#123;</span><br><span class="line">            throw new IllegalArgumentException(&quot;Message must have a target.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        if (msg.isInUse()) &#123;</span><br><span class="line">            throw new IllegalStateException(msg + &quot; This message is already in use.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        //注意这里的synchronized字段的作用。</span><br><span class="line">        synchronized (this) &#123;</span><br><span class="line">            if (mQuitting) &#123;</span><br><span class="line">                IllegalStateException e = new IllegalStateException(</span><br><span class="line">                        msg.target + &quot; sending message to a Handler on a dead thread&quot;);</span><br><span class="line">                Log.w(TAG, e.getMessage(), e);</span><br><span class="line">                msg.recycle();</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ...具体的加入到队列的逻辑我们不分析，省略该部分代码</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>通过上面的分析，我们可以得出结论：<code>Handler</code>的不同线程数据传输其实就是通过共享变量来实现的，而他们之间的介质便是<code>Message</code>。</p>
<p>2、<code>view.post(Runnable runable)</code>和<code>mHandler.post(Runnable runnable)</code>之间的关联是什么？为何在<code>Activity</code>的<code>onCreate()</code>中调用<code>view.gitHeight()</code>返回0，而使用<code>view.post(Runnable runable)</code>之后可以正确的返回<code>View</code>的高度？</p>
<p>关于这个问题，我将会用另一篇文章来单独分析~</p>
<p><a href="http://www.kcrason.com" target="_blank" rel="noopener">Welcome to KCrason’s blog</a></p>

        </div>

        
        <section class="post-tags">
            <div>
                <span>Tag(s):</span>
                <span class="tag">
                    
                    
                        <a href="/tags/handler机制/"># handler机制</a>
                    
                        
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">back</a>
                <span>· </span>
                <a href="/">home</a>
            </div>
        </section>
        <section class="post-nav">
            
                <a class="prev" rel="prev" href="/2018/01/24/仿爱奇艺腾讯视频ViewPager导航条实现/">仿爱奇艺腾讯视频ViewPager导航条实现</a>
            
            
            <a class="next" rel="next" href="/2017/12/04/Hexo+NexT+GitHub简易建站流程/">Hexo+NexT+GitHub简易建站流程</a>
            
        </section>


    </article>
</div>

        </div>
        <footer id="footer" class="footer">
    <div class="copyright">
        <span>© KCrason | Powered by <a href="https://hexo.io" target="_blank">Hexo</a> & <a href="https://github.com/Siricee/hexo-theme-Chic" target="_blank">Chic</a></span>
    </div>
</footer>

    </div>
</body>
</html>
