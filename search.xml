<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Android Binder通信方式-手动实现binder双向通信]]></title>
    <url>%2F2019%2F09%2F28%2FAndroid-Binder%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F-%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0binder%E5%8F%8C%E5%90%91%E9%80%9A%E4%BF%A1%2F</url>
    <content type="text"><![CDATA[待更新…]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Binder通信</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Binder通信方式-AIDL语言实现binder通信]]></title>
    <url>%2F2019%2F09%2F28%2FAndroid-Binder%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F-AIDL%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0binder%E9%80%9A%E4%BF%A1%2F</url>
    <content type="text"><![CDATA[待更新…]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Binder通信</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Binder通信方式-Messenger实现binder通信]]></title>
    <url>%2F2019%2F09%2F28%2FAndroid-Binder%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F-Messenger%E5%AE%9E%E7%8E%B0binder%E9%80%9A%E4%BF%A1%2F</url>
    <content type="text"><![CDATA[Android实现binder通信的方式是多样的，但是主要的最为常用的还是使用AIDL语言去实现，也是Android推荐的一种方式，但是为了更好的了解binder通信，我们先了解一种Android官方已经为我们封装好的binder通信方式，即Messenger。对于Messenger，可能很多人都不怎么熟悉，因为我们平时大部分时间可能使用的Message进行线程间的消息传递，对于Messenger这样一个名词会有所陌生，它们两者之间虽然名称差不多，但是用处却大不相同，因此要注意区别。如何使用Messenger进程binder通信？事实上，要在两个进程间进行通信，首先需要运行两个不同的进程。其次，进行binder通信，远程IBinder也是不可或缺的。了解了这些基础，我们就可以开始了。一、创建远程服务端（Binder服务端）创建远程服务端（Binder服务端）1.1 创建Messenger Service创建Messenger Service的目的是因为使用bindService的方式启动一个服务可以回调一个IBinder对象给远程进程端。123456class MessengerService : Service() &#123; override fun onBind(intent: Intent?): IBinder? &#123; return MessengerBinder().getMessengerBinder() &#125;&#125;1.2 创建MessengerHander管理Messenger123456789101112131415161718192021class MessengerBinder &#123; companion object &#123; const val MSG_CODE = 0x100 &#125; class MessengerHandler : Handler() &#123; override fun handleMessage(msg: Message) &#123; if (msg.arg1 == MSG_CODE) &#123; if (DEBUG) &#123; //单向通信，无法回复。 Log.d("KCrason", "Messenger服务端接收到数据后") &#125; &#125; &#125; &#125; fun getMessengerBinder(): IBinder &#123; return Messenger(MessengerHandler()).binder &#125;&#125;可以看到，在创建一个Messenger对象时候，需要传入一个Handler对象，该Handler对象主要是用来回调客户端发送的消息。同时Messenger对象创建后，会创建一个IBinder对象，用于返回给远程Service，即前面创建的MessengerService。通过前面两个步骤，我们已经完成了远程进程的创建工作，当然，要想让MessengerService运行在新的进程中，还需要在manifest文件中声明process属性。123&lt;service android:name=".service.MessengerService" android:process=".MessengerService" /&gt;二、创建通信发起端进程（Binder客户端）客户端的创建很简单，就是通过bindService的方式，启动上面创建的远程服务，此时在客户端发送一个消息给远程服务端，服务端收到消息，则流程就算完成。12345678910111213141516171819202122232425class MessengerCommunicationClient : AppCompatActivity() &#123; override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) bindService( Intent(this, MessengerService::class.java), object : ServiceConnection &#123; override fun onServiceDisconnected(name: ComponentName?) &#123; &#125; override fun onServiceConnected(name: ComponentName?, service: IBinder?) &#123; val messenger = Messenger(service) val message = Message().apply &#123; arg1 = MessengerBinder.MSG_CODE &#125; if (DEBUG) &#123; Log.d("KCrason", "Messenger客户端发送前") &#125; messenger.send(message) &#125; &#125;, Context.BIND_AUTO_CREATE ) &#125;&#125;可以看到，我们在服务启动完成之后，回调onServiceConnected方法，通过远程服务端的IBinder对象创建一个新的Messenger对象用于发送消息。发送消息就只要构建一个简单的Message对象即可。运行之后可以发现MessengerService运行在.MessengerService进程。MessengerCommunicationClient运行在启动的APP进程。通过在App端进程发送一条测试消息，成功在服务端进程接收到。到此，使用Messenger进行Binder通信的流程就算完成。当然，Messenger具体帮助我们干了啥，后面再仔细研究。三、Messenger进程通信的优缺点3.1 优点很明显，使用Messenger进行Binder通信流程清晰，简单易懂。没有很复杂的过程。3.2 缺点由于我们使用Message传递消息，这就很容易限制消息的传递的方式。如果我们想直接调用服务端的方法，显然是不方便的。再者在进行并非请求时，使用Message队列方式明显效率低下。其次，如果我们想在远程服务端回复一条消息给客户端，使用Messenger方式我们是没有办法实现的。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Binder通信</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Binder通信#开篇#]]></title>
    <url>%2F2019%2F09%2F28%2FAndroid-Binder%E9%80%9A%E4%BF%A1-%E5%BC%80%E7%AF%87%2F</url>
    <content type="text"><![CDATA[概述熟悉Android开发的人都知道，Android系统间的进程通信方式主要是使用Binder机制的，当然，也不乏用到了其它的一些机制，比如Socket套接字、Single信号量进行通信，但是Android不同进程间的主要通信机制还是依靠的Binder。那么Binder到底是为什么会成为Android进程间的主要通信方式？Binder到底是如何进行进程间的通信的？Binder机制1、为什么Android选用Binder进行通信Android选用Binder进行通信主要有两方面的考虑性能方面：在移动设备上，广泛的使用跨进程通信对性能有严格要求，Binder相对其他的通信方式更加高效。Binder数据拷贝只需要一次，而管道、消息队列、Socket都需要2次，共享内存方式一次内存拷贝都不需要，但实现方式又比较复杂。安全方面：传统的进程通信方式对于通信双方的身份并没有做出严格的验证，比如Socket通信ip地址是客户端手动填入，很容易进行伪造，而Binder机制从协议本身就支持对通信双方做身份校检，因而大大提升了安全性。2、Binder是如何进行通信的我们知道，不同的Android应用程序之间是无法共享内存的。每个应用程序在创建之后就与其他的应用程序完全隔离。而要想让两个不同的应用程序进行通信，那么我们必须从底层入手。Android应用程序是基于Linux内核的，也就是说通过共享内核空间即可完成通信过程。Android Binder通信实际上是一种包含客户端和服务端角色的C/S架构。通过上面的通信机制图形我们可以知道。通信依靠的对象主要有以下几个。客户端：客户端我们可以把他认为是需要与其它进程进行通信的一端。当客户端需要与其他进程进行通信时，通过获取其他进程在Service Manager注册的远程服务来发送消息。消息发送出去了，再通过Binder驱动传递至内核空间，内核空间再返回给远程进程（服务端）。服务端：而服务端则作为被通信的一方，通过向Service Manager注册远程服务来提供给客户端调用。当然客户端和服务端的角色不是绝对的。在实际的通信过程中，作为客户端的一方也可以有时候也可以被认为是服务端，服务端的一方可以被认为是客户端。ServiceManager进程：如果你了解Android的启动过程，就知道Service Manger进程是由init进程启动，主要用于管理远程服务。主要包括注册和查询服务。ServiceManger进程启动后会打开Binder设备，并在内存中映射128k的空间。之后告诉Binder驱动自己是Binder的上下文管理者。之后进入循环，检索客户端的请求。Binder驱动：它主要负责进程之间Binder通信的建立，Binder引用计数管理，数据包在进程之间的传递和交互等一系列底层支持。3、Android中Binder的具体应用方式Android中进行Binder通信是及其方便的，尽管我们大致了解了Binder基本原理，但实际上，了解Framework层Binder通信流程才是最重要的。后续将通过三篇文章来阐述应用层Binder通信的具体实现方式。通过这三篇文章，我们可以对Binder的流程有更为清晰的认识。Android Binder通信方式-Messenger实现binder通信Android Binder通信方式-AIDL语言实现binder通信Android Binder通信方式-手动实现binder双向通信]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Binder通信</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[类似微信根据手指长按位置精准弹出的PopupWindow]]></title>
    <url>%2F2019%2F08%2F14%2F%E7%B1%BB%E4%BC%BC%E5%BE%AE%E4%BF%A1%E6%A0%B9%E6%8D%AE%E6%89%8B%E6%8C%87%E9%95%BF%E6%8C%89%E4%BD%8D%E7%BD%AE%E7%B2%BE%E5%87%86%E5%BC%B9%E5%87%BA%E7%9A%84PopupWindow%2F</url>
    <content type="text"><![CDATA[类似微信根据手指长按位置精准弹出的PopupWindow，自动根据左右上下边距调整显示的方向。APK体验包项目地址准备工作1、导入依赖1implementation &apos;com.kcrason:motionevent-popupwindow:1.0.0&apos;简单使用(纯微信效果)1、在需要显示的Activity重写dispatchTouchEvent，并设置一个变量用于保存motionEvent。（如果需要设置一个全局的MotionEvent，则需要在BaseActivity重写dispatchTouchEvent并提供一个方法获取motionEvent对象即可）1234override fun dispatchTouchEvent(ev: MotionEvent?): Boolean &#123; this.mMotionEvent = ev return super.dispatchTouchEvent(ev) &#125;2、给需要触发显示popupwindow的view设置单击或长按时显示popupwindow，显示popupwindow时，将motionEvent变量传递进去。123456789txtCenterClick.setOnLongClickListener &#123; CommonMotionEventPopupWindow(this) .showOptions(arrayListOf(&quot;复制&quot;, &quot;粘贴&quot;, &quot;发送&quot;, &quot;翻译&quot;, &quot;发送给好友&quot;)) .setOnClickItemOptionsListener &#123; position, optionName -&gt; Toast.makeText(this, &quot;this is $position , optionName:$optionName&quot;, Toast.LENGTH_SHORT).show() &#125; .showMotionEventPopupWindow(it, mMotionEvent) return@setOnLongClickListener true &#125;自定义界面的Popupwindow1、创建新类继承BaseMotionEventPopupWindow即可。1234567891011121314151617class CustomMotionEventPopupWindow(context: Context) :BaseMotionEventPopupWindow(context) &#123; override fun init() &#123; //初始化一些参数 &#125; override fun getContainerLayoutId(): Int &#123; //返回你需要显示的popupwindow xml &#125; override fun getRealPopupWindowHeight(): Int &#123; //返回popupwindow真实的高度，该高度在计算显示popupwindow的位置时需要用到，必须保证其准确性。 &#125; override fun getWindowWidth(): Int &#123; //返回popupwindow的宽度，一般使用固定的值即可。 &#125;&#125;2、在需要显示的地方调用showMotionEventPopupWindow(anchor: View?, currentMotionEvent: MotionEvent?)方法显示popupwindow效果展示结语实现比较简单，就不做过多介绍了，有兴趣可以download代码查看。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>PopupWindow</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[经典讲解HashMap工作原理[转载]]]></title>
    <url>%2F2018%2F05%2F13%2F%E7%BB%8F%E5%85%B8%E8%AE%B2%E8%A7%A3HashMap%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86-%E8%BD%AC%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[本文由ImportNew-Wing翻译自coding-geek。大部分Java开发者都在使用Map，特别是HashMap。HashMap是一种简单但强大的方式去存储和获取数据。但有多少开发者知道HashMap内部如何工作呢？几天前，我阅读了java.util.HashMap的大量源代码（包括Java 7 和Java 8），来深入理解这个基础的数据结构。在这篇文章中，我会解释java.util.HashMap的实现，描述Java 8实现中添加的新特性，并讨论性能、内存以及使用HashMap时的一些已知问题。Java HashMap类实现了Map&lt;K, V&gt;接口。这个接口中的主要方法包括：V put(K key, V value)V get(Object key)V remove(Object key)Boolean containsKey(Object key)HashMap使用了一个内部类Entry&lt;K, V&gt;来存储数据。这个内部类是一个简单的键值对，并带有额外两个数据：一个指向其他入口（译者注：引用对象）的引用，这样HashMap可以存储类似链接列表这样的对象。一个用来代表键的哈希值，存储这个值可以避免HashMap在每次需要时都重新生成键所对应的哈希值。下面是Entry&lt;K, V&gt;在Java 7下的一部分代码：1234567static class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; final K key; V value; Entry&lt;K,V&gt; next; int hash; …&#125;HashMap将数据存储到多个单向Entry链表中（有时也被称为桶bucket或者容器orbins）。所有的列表都被注册到一个Entry数组中（Entry&lt;K, V&gt;[]数组），这个内部数组的默认长度是16。下面这幅图描述了一个HashMap实例的内部存储，它包含一个nullable对象组成的数组。每个对象都连接到另外一个对象，这样就构成了一个链表。所有具有相同哈希值的键都会被放到同一个链表（桶）中。具有不同哈希值的键最终可能会在相同的桶中。当用户调用 put(K key， V value) 或者 get(Object key) 时，程序会计算对象应该在的桶的索引。然后，程序会迭代遍历对应的列表，来寻找具有相同键的Entry对象（使用键的equals()方法）。对于调用get()的情况，程序会返回值所对应的Entry对象（如果Entry对象存在）。对于调用put(K key, V value)的情况，如果Entry对象已经存在，那么程序会将值替换为新值，否则，程序会在单向链表的表头创建一个新的Entry（从参数中的键和值）。桶（链表）的索引，是通过map的3个步骤生成的：首先获取键的散列码。程序重复散列码，来阻止针对键的糟糕的哈希函数，因为这有可能会将所有的数据都放到内部数组的相同的索引（桶）上。程序拿到重复后的散列码，并对其使用数组长度（最小是1）的位掩码（bit-mask）。这个操作可以保证索引不会大于数组的大小。你可以将其看做是一个经过计算的优化取模函数。下面是生成索引的源代码：12345678910111213static int hash(int h) &#123; h ^= (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12); return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4);&#125;static final int hash(Object key) &#123; int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);&#125;static int indexFor(int h, int length) &#123; return h &amp; (length-1);&#125;为了更有效地工作，内部数组的大小必须是2的幂值。让我们看一下为什么：假设数组的长度是17，那么掩码的值就是16（数组长度-1）。16的二进制表示是0…010000，这样对于任何值H来说，“H &amp; 16”的结果就是16或者0。这意味着长度为17的数组只能应用到两个桶上：一个是0，另外一个是16，这样不是很有效率。但是如果你将数组的长度设置为2的幂值，例如16，那么按位索引的工作变成“H &amp; 15”。15的二进制表示是0…001111，索引公式输出的值可以从0到15，这样长度为16的数组就可以被充分使用了。例如：如果H = 952，它的二进制表示是0..01110111000，对应的索引是0…01000 = 8如果H = 1576，它的二进制表示是0..011000101000，对应的索引是0…01000 = 8如果H = 12356146，它的二进制表示是0..0101111001000101000110010，对应的索引是0…00010 = 2如果H = 59843，它的二进制表示是0..01110100111000011，它对应的索引是0…00011 = 3这种机制对于开发者来说是透明的：如果他选择一个长度为37的HashMap，Map会自动选择下一个大于37的2的幂值（64）作为内部数组的长度。在获取索引后，get()、put()或者remove()方法会访问对应的链表，来查看针对指定键的Entry对象是否已经存在。在不做修改的情况下，这个机制可能会导致性能问题，因为这个方法需要迭代整个列表来查看Entry对象是否存在。假设内部数组的长度采用默认值16，而你需要存储2，000,000条记录。在最好的情况下，每个链表会有125,000个Entry对象（2,000,000/16）。get()、remove()和put()方法在每一次执行时，都需要进行125,000次迭代。为了避免这种情况，HashMap可以增加内部数组的长度，从而保证链表中只保留很少的Entry对象。当你创建一个HashMap时，你可以通过以下构造函数指定一个初始长度，以及一个loadFactor：1public HashMap(int initialCapacity, float loadFactor)如果你不指定参数，那么默认的initialCapacity的值是16loadFactor的默认值是0.75。initialCapacity代表内部数组的链表的长度。当你每次使用put(…)方法向Map中添加一个新的键值对时，该方法会检查是否需要增加内部数组的长度。为了实现这一点，Map存储了2个数据：Map的大小：它代表HashMap中记录的条数。我们在向HashMap中插入或者删除值时更新它。阀值：它等于内部数组的长度*loadFactor，在每次调整内部数组的长度时，该阀值也会同时更新。在添加新的Entry对象之前，put(…)方法会检查当前Map的大小是否大于阀值。如果大于阀值，它会创建一个新的数组，数组长度是当前内部数组的两倍。因为新数组的大小已经发生改变，所以索引函数（就是返回“键的哈希值 &amp; (数组长度-1)”的位运算结果）也随之改变。调整数组的大小会创建两个新的桶（链表），并且将所有现存Entry对象重新分配到桶上。调整数组大小的目标在于降低链表的大小，从而降低put()、remove()和get()方法的执行时间。对于具有相同哈希值的键所对应的所有Entry对象来说，它们会在调整大小后分配到相同的桶中。但是，如果两个Entry对象的键的哈希值不一样，但它们之前在同一个桶上，那么在调整以后，并不能保证它们依然在同一个桶上。这幅图片描述了调整前和调整后的内部数组的情况。在调整数组长度之前，为了得到Entry对象E，Map需要迭代遍历一个包含5个元素的链表。在调整数组长度之后，同样的get()方法则只需要遍历一个包含2个元素的链表，这样get()方法在调整数组长度后的运行速度提高了2倍。如果你已经非常熟悉HashMap，那么你肯定知道它不是线程安全的，但是为什么呢？例如假设你有一个Writer线程，它只会向Map中插入已经存在的数据，一个Reader线程，它会从Map中读取数据，那么它为什么不工作呢？因为在自动调整大小的机制下，如果线程试着去添加或者获取一个对象，Map可能会使用旧的索引值，这样就不会找到Entry对象所在的新桶。在最糟糕的情况下，当2个线程同时插入数据，而2次put()调用会同时出发数组自动调整大小。既然两个线程在同时修改链表，那么Map有可能在一个链表的内部循环中退出。如果你试着去获取一个带有内部循环的列表中的数据，那么get()方法永远不会结束。HashTable提供了一个线程安全的实现，可以阻止上述情况发生。但是，既然所有的同步的CRUD操作都非常慢。例如，如果线程1调用get(key1)，然后线程2调用get(key2)，线程2调用get(key3)，那么在指定时间，只能有1个线程可以得到它的值，但是3个线程都可以同时访问这些数据。从Java 5开始，我们就拥有一个更好的、保证线程安全的HashMap实现：ConcurrentHashMap。对于ConcurrentMap来说，只有桶是同步的，这样如果多个线程不使用同一个桶或者调整内部数组的大小，它们可以同时调用get()、remove()或者put()方法。在一个多线程应用程序中，这种方式是更好的选择。为什么将字符串和整数作为HashMap的键是一种很好的实现？主要是因为它们是不可变的！如果你选择自己创建一个类作为键，但不能保证这个类是不可变的，那么你可能会在HashMap内部丢失数据。我们来看下面的用例：你有一个键，它的内部值是“1”。你向HashMap中插入一个对象，它的键就是“1”。HashMap从键（即“1”）的散列码中生成哈希值。Map在新创建的记录中存储这个哈希值。你改动键的内部值，将其变为“2”。键的哈希值发生了改变，但是HashMap并不知道这一点（因为存储的是旧的哈希值）。你试着通过修改后的键获取相应的对象。Map会计算新的键（即“2”）的哈希值，从而找到Entry对象所在的链表（桶）。情况1： 既然你已经修改了键，Map会试着在错误的桶中寻找Entry对象，没有找到。情况2： 你很幸运，修改后的键生成的桶和旧键生成的桶是同一个。Map这时会在链表中进行遍历，已找到具有相同键的Entry对象。但是为了寻找键，Map首先会通过调用equals()方法来比较键的哈希值。因为修改后的键会生成不同的哈希值（旧的哈希值被存储在记录中），那么Map没有办法在链表中找到对应的Entry对象。下面是一个Java示例，我们向Map中插入两个键值对，然后我修改第一个键，并试着去获取这两个对象。你会发现从Map中返回的只有第二个对象，第一个对象已经“丢失”在HashMap中：12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class MutableKeyTest &#123; public static void main(String[] args) &#123; class MyKey &#123; Integer i; public void setI(Integer i) &#123; this.i = i; &#125; public MyKey(Integer i) &#123; this.i = i; &#125; @Override public int hashCode() &#123; return i; &#125; @Override public boolean equals(Object obj) &#123; if (obj instanceof MyKey) &#123; return i.equals(((MyKey) obj).i); &#125; else return false; &#125; &#125; Map&lt;MyKey, String&gt; myMap = new HashMap&lt;&gt;(); MyKey key1 = new MyKey(1); MyKey key2 = new MyKey(2); myMap.put(key1, "test " + 1); myMap.put(key2, "test " + 2); key1.setI(3); String test1 = myMap.get(key1); String test2 = myMap.get(key2); System.out.println("test1= " + test1 + " test2=" + test2); &#125;&#125;上述代码的输出是“test1=null test2=test 2”。如我们期望的那样，Map没有能力获取经过修改的键 1所对应的字符串1。在Java 8中，HashMap中的内部实现进行了很多修改。的确如此，Java 7使用了1000行代码来实现，而Java 8中使用了2000行代码。我在前面描述的大部分内容在Java 8中依然是对的，除了使用链表来保存Entry对象。在Java 8中，我们仍然使用数组，但它会被保存在Node中，Node中包含了和之前Entry对象一样的信息，并且也会使用链表：下面是在Java 8中Node实现的一部分代码：123456static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; final int hash; final K key; V value; Node&lt;K,V&gt; next;&#125;那么和Java 7相比，到底有什么大的区别呢？好吧，Node可以被扩展成TreeNode。TreeNode是一个红黑树的数据结构，它可以存储更多的信息，这样我们可以在O(log(n))的复杂度下添加、删除或者获取一个元素。下面的示例描述了TreeNode保存的所有信息：123456789101112static final class TreeNode&lt;K,V&gt; extends LinkedHashMap.Entry&lt;K,V&gt; &#123; final int hash; final K key; V value; Node&lt;K,V&gt; next; Entry&lt;K,V&gt; before, after; TreeNode&lt;K,V&gt; parent; TreeNode&lt;K,V&gt; left; TreeNode&lt;K,V&gt; right; TreeNode&lt;K,V&gt; prev; boolean red;&#125;红黑树是自平衡的二叉搜索树。它的内部机制可以保证它的长度总是log(n)，不管我们是添加还是删除节点。使用这种类型的树，最主要的好处是针对内部表中许多数据都具有相同索引（桶）的情况，这时对树进行搜索的复杂度是O(log(n))，而对于链表来说，执行相同的操作，复杂度是O(n)。如你所见，我们在树中确实存储了比链表更多的数据。根据继承原则，内部表中可以包含Node（链表）或者TreeNode（红黑树）。Oracle决定根据下面的规则来使用这两种数据结构：对于内部表中的指定索引（桶），如果node的数目多于8个，那么链表就会被转换成红黑树。对于内部表中的指定索引（桶），如果node的数目小于6个，那么红黑树就会被转换成链表。这张图片描述了在Java 8 HashMap中的内部数组，它既包含树（桶0），也包含链表（桶1，2和3）。桶0是一个树结构是因为它包含的节点大于8个。JAVA 7使用HashMap会消耗一些内存。在Java 7中，HashMap将键值对封装成Entry对象，一个Entry对象包含以下信息：指向下一个记录的引用一个预先计算的哈希值（整数）一个指向键的引用一个指向值的引用此外，Java 7中的HashMap使用了Entry对象的内部数组。假设一个Java 7 HashMap包含N个元素，它的内部数组的容量是CAPACITY，那么额外的内存消耗大约是：1sizeOf(integer)* N + sizeOf(reference)* (3*N+C)其中：整数的大小是4个字节引用的大小依赖于JVM、操作系统以及处理器，但通常都是4个字节。这就意味着内存总开销通常是16 * N + 4 * CAPACITY字节。注意：在Map自动调整大小后，CAPACITY的值是下一个大于N的最小的2的幂值。注意：从Java 7开始，HashMap采用了延迟加载的机制。这意味着即使你为HashMap指定了大小，在我们第一次使用put()方法之前，记录使用的内部数组（耗费4*CAPACITY字节）也不会在内存中分配空间。JAVA 8在Java 8实现中，计算内存使用情况变得复杂一些，因为Node可能会和Entry存储相同的数据，或者在此基础上再增加6个引用和一个Boolean属性（指定是否是TreeNode）。如果所有的节点都只是Node，那么Java 8 HashMap消耗的内存和Java 7 HashMap消耗的内存是一样的。如果所有的节点都是TreeNode，那么Java 8 HashMap消耗的内存就变成：1N * sizeOf(integer) + N * sizeOf(boolean) + sizeOf(reference)* (9*N+CAPACITY )在大部分标准JVM中，上述公式的结果是44 * N + 4 * CAPACITY 字节。非对称HashMap vs 均衡HashMap在最好的情况下，get()和put()方法都只有O(1)的复杂度。但是，如果你不去关心键的哈希函数，那么你的put()和get()方法可能会执行非常慢。put()和get()方法的高效执行，取决于数据被分配到内部数组（桶）的不同的索引上。如果键的哈希函数设计不合理，你会得到一个非对称的分区（不管内部数据的是多大）。所有的put()和get()方法会使用最大的链表，这样就会执行很慢，因为它需要迭代链表中的全部记录。在最坏的情况下（如果大部分数据都在同一个桶上），那么你的时间复杂度就会变为O(n)。下面是一个可视化的示例。第一张图描述了一个非对称HashMap，第二张图描述了一个均衡HashMap。在这个非对称HashMap中，在桶0上运行get()和put()方法会很花费时间。获取记录K需要花费6次迭代。在这个均衡HashMap中，获取记录K只需要花费3次迭代。这两个HashMap存储了相同数量的数据，并且内部数组的大小一样。唯一的区别是键的哈希函数，这个函数用来将记录分布到不同的桶上。下面是一个使用Java编写的极端示例，在这个示例中，我使用哈希函数将所有的数据放到相同的链表（桶），然后我添加了2,000,000条数据。12345678910111213141516171819202122232425262728293031public class Test &#123; public static void main(String[] args) &#123; class MyKey &#123; Integer i; public MyKey(Integer i)&#123; this.i =i; &#125; @Override public int hashCode() &#123; return 1; &#125; @Override public boolean equals(Object obj) &#123; … &#125; &#125; Date begin = new Date(); Map &lt;MyKey,String&gt; myMap= new HashMap&lt;&gt;(2_500_000,1); for (int i=0;i&lt;2_000_000;i++)&#123; myMap.put( new MyKey(i), "test "+i); &#125; Date end = new Date(); System.out.println("Duration (ms) "+ (end.getTime()-begin.getTime())); &#125;&#125;我的机器配置是core i5-2500k @ 3.6G，在java 8u40下需要花费超过45分钟的时间来运行（我在45分钟后停止了进程）。如果我运行同样的代码， 但是我使用如下的hash函数：12345 @Override public int hashCode() &#123; int key = 2097152-1; return key+2097152*i;&#125;运行它需要花费46秒，和之前比，这种方式好很多了！新的hash函数比旧的hash函数在处理哈希分区时更合理，因此调用put()方法会更快一些。如果你现在运行相同的代码，但是使用下面的hash函数，它提供了更好的哈希分区：1234@Overridepublic int hashCode() &#123; return i;&#125;现在只需要花费2秒！我希望你能够意识到哈希函数有多重要。如果在Java 7上面运行同样的测试，第一个和第二个的情况会更糟（因为Java 7中的put()方法复杂度是O(n)，而Java 8中的复杂度是O(log(n))。在使用HashMap时，你需要针对键找到一种哈希函数，可以将键扩散到最可能的桶上。为此，你需要避免哈希冲突。String对象是一个非常好的键，因为它有很好的哈希函数。Integer也很好，因为它的哈希值就是它自身的值。调整大小的开销如果你需要存储大量数据，你应该在创建HashMap时指定一个初始的容量，这个容量应该接近你期望的大小。如果你不这样做，Map会使用默认的大小，即16，factorLoad的值是0.75。前11次调用put()方法会非常快，但是第12次（16*0.75）调用时会创建一个新的长度为32的内部数组（以及对应的链表/树），第13次到第22次调用put()方法会很快，但是第23次（32*0.75）调用时会重新创建（再一次）一个新的内部数组，数组的长度翻倍。然后内部调整大小的操作会在第48次、96次、192次…..调用put()方法时触发。如果数据量不大，重建内部数组的操作会很快，但是数据量很大时，花费的时间可能会从秒级到分钟级。通过初始化时指定Map期望的大小，你可以避免调整大小操作带来的消耗。但这里也有一个缺点：如果你将数组设置的非常大，例如2^28，但你只是用了数组中的2^26个桶，那么你将会浪费大量的内存（在这个示例中大约是2^30字节）。对于简单的用例，你没有必要知道HashMap是如何工作的，因为你不会看到O(1)、O(n)以及O(log(n))之间的区别。但是如果能够理解这一经常使用的数据结构背后的机制，总是有好处的。另外，对于Java开发者职位来说，这是一道典型的面试问题。对于大数据量的情况，了解HashMap如何工作以及理解键的哈希函数的重要性就变得非常重要。我希望这篇文章可以帮助你对HashMap的实现有一个深入的理解。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>HashMap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[实现高性能微信朋友圈]]></title>
    <url>%2F2018%2F05%2F13%2F%E5%AE%9E%E7%8E%B0%E9%AB%98%E6%80%A7%E8%83%BD%E5%BE%AE%E4%BF%A1%E6%9C%8B%E5%8F%8B%E5%9C%88%2F</url>
    <content type="text"><![CDATA[众所周知，微信朋友圈的列表一直以来被众多研究性能问题的朋友拿来作为模范，对于其实现方式，一直以来有点难以望其项背的感觉。只能默默的感叹微信的开发者是真的牛逼。经过一段时间的研究，现在我将带领大家以全新的认知对微信朋友圈的结构进行分析，并通过自己的方式加以实现。先上图：GIF看着有点卡，可以下载apk自行体验，流畅度和微信几乎无差别：app-debug.apk源码地址：HighPerformanceFriendsCircle我们都知道，在Android中，对于列表的而言，要避免其卡顿，可以从以下几个角度进行优化。1、减少布局层级，避免过多的Item View的无用布局嵌套。2、对于有图片的列表，要在滑动时对图片加以控制，即滑动时不加载图片，停止滑动之后再加载图片。3、应当避免在Adapter的填充数据时做过多的计算，或者嵌套过多的逻辑判断。对于复杂的计算结果应当在Adapter填充数据之前计算完成。以上这些都是针对一个普通的Adapter所基本的一些优化，而对于微信朋友圈这种复杂列表，除了以上几种之外，还需要对其进行其他方面的优化。例如包括减少View的重复创建，构建缓存View，以及减少布局的onMeasure和onLayout次数。这些都尤为重要。下面我们先简单分析一些微信的列表每一项的视图结构，通过分析微信，我们可以参悟到一些自己的解决思路。首先我们通过Android Device Monitor视图分析器来分析微信朋友圈的每一个Item的视图结构。从图中我们可以知道，它的Item最外部是一个FramLayout，里面的内容都是一些常见的View，关键的地方在于评论列表的构建，我们知道，微信的评论是直接在列表内展示的，在这里我们发现它的评论列表其实就是一个用一个LinearLayout进行包裹的。而由于每条动态评论的不确定性，我们需要在adapter中不断的创建评论View和移除多余的View，就这涉及到性能问题，那么微信到底是如何在一个Item中展示多条评论又不出现明显的卡顿现象呢？在ViewGroup中，有个一方法可能一直被大家所忽略，它就是addViewInLayout()，由于它是protected声明的，所以外部的ViewGroup的子类无法直接调用，而要使用addViewInLayout()，必须继承ViewGroup或ViewGroup的子类并重写该方法。那么addViewInLayout()方法究竟有何用呢？它和我们常用的addView()又有什么区别呢？我们先来看官方对addViewInLayout()的解释：简单翻译：在布局中添加视图。 如果在onLayout()方法中，您需要添加更多视图（例如列表视图），这非常有用。 如果索引是负数，则意味着将其放在列表的末尾。这似乎没什么特殊的，但是它真正的有用的地方在于该方法中的preventRequestLayout参数，这是一个boolean类型的值，但是它确实及其有用的。如果为true，在添加View时他将不会触发子对象的布局请求。也就是说添加View时不会触发onMeasure和onLayout操作。官方api解释图：通过对addViewInLayout()的分析，我想你大概明白了，既然动态添加View的时候可以不用触发onMeasure()和onLayout()，那将大量的节约adapter的刷新速度。上面我们有提到过，对adapter的性能要点中，减少adapter Item的onMeasure和onLayout尤为重要（因为事实上View的显示onMeasure和onLayout需要耗费大量的时间）。同样的，在移除View时，我们可以使用removeViewInLayout()，它有和addViewInLayout()一样的效果。因此，通过这个办法，我们解决了评论列表的动态变化更新的性能问题。而九宫格图片的展示只需要自定义ViewGroup即可实现，其内部依然是对ImageView的添加和移除，同样的我们可以使用该方法addViewInLayout()和removeViewInLayout()来减少onMeasure()和onLayout()的次数以节省性能开支。其他方面的优化则是尽管在数据Bean中完成对各种数据变换的操作，包括复杂的计算，比如将String转换成需要的SpannableStringBuilder等。最后就是除了要减少onMeasure()和onLayout()的次数之后，我们也需要减少View的创建。减少View的创建我们可以使用一个弱引用的缓存数组和实现View对象的缓存，这里要感谢razerdp提供的思路。具体的一些其他逻辑，代码中自行研究吧，后续可能还会继续更新该项目，包括表情的匹配，电话号码的匹配等，看自己时间情况。欢迎大家start！特别说明：昨天有一位网友提出了一个问题，后面经过分析，发现在adapter中使用addViewInLayout()和addView()去添加一个或多个View无异，也就是说在adapter中构建评论数据时使用addViewInLayout()并不会减少onMeasure()和onLayout()的次数，原因后续再单独出一篇文章进行说明，这里感谢@Caij的指正！]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Wechat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[仿爱奇艺腾讯视频ViewPager导航条实现]]></title>
    <url>%2F2018%2F01%2F24%2F%E4%BB%BF%E7%88%B1%E5%A5%87%E8%89%BA%E8%85%BE%E8%AE%AF%E8%A7%86%E9%A2%91ViewPager%E5%AF%BC%E8%88%AA%E6%9D%A1%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[DynamicPagerIndicator仿爱奇艺/腾讯视频ViewPager导航条实现，支持自定义导航条高度，宽度，颜色变化，字体大小变化。支持多种滚动模式，支持自定义每个TabView的样式。Demo体验：app-debug.apk一、如何引入DynamicPagerIndicator？1234在module的build.gradle 添加:compile &apos;com.kcrason:dynamicpagerindicator:1.5.0&apos;3.0以上gradle版本为：implementation &apos;com.kcrason:dynamicpagerindicator:1.5.0&apos;二、如何使用？1、将DynamicPagerIndicator 添加到指定xml1234567&lt;com.kcrason.dynamicpagerindicatorlibrary.DynamicPagerIndicator android:id=&quot;@+id/dynamic_pager_indicator1&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; app:indicatorLineScrollMode=&quot;dynamic&quot; app:pagerIndicatorMode=&quot;scrollable_center&quot; /&gt;2、将ViewPager对象设置给DynamicPagerIndicator123ViewPager viewPager = findViewById(R.id.view_pager);DynamicPagerIndicator dynamicPagerIndicator = findViewById(R.id.dynamic_pager_indicator);dynamicPagerIndicator.setViewPager(viewPager);三、属性说明pagerIndicatorMode : 指示器的显示模式，共有三种。1、scrollable：适用于ViewPager的count较多时。可滑动。默认从左向右排列显示2、scrollable_center：居中显示，适用于ViewPager的count较少时，且需要居中显示3、fixed：均分模式，该模式下会平均分配TabView的宽度tabPadding：其为TabView的左右内边距。tabNormalTextSize：其为TabView中Title的文字正常状态文字大小。tabSelectedTextSize：其为TabView中Title的文字选中状态文字大小。tabNormalTextColor：其为TabView中Title的文字正常状态文字颜色。tabSelectedTextColor：其为TabView中Title的文字选中状态文字颜色。tabTextColorMode/tabTextSizeMode：其为TabView的Title文字颜色和字体变化模式，共两中：common：普通变化；gradient：渐变模式。indicatorLineHeight：其为TabView下的导航条的高度。indicatorLineWidth：其为TabView下的导航条的宽度。indicatorLineRadius：其为TabView下的导航条的圆角，默认为0，即不绘制圆角。indicatorLineStartColor：其为TabView下的导航条变化的开始颜色。如果不需要颜色变换效果，将indicatorLineStartColor和indicatorLineEndColor设置成一致即可。indicatorLineEndColor：其为TabView下的导航条变化的结束颜色。如果不需要颜色变换效果，将indicatorLineStartColor和indicatorLineEndColor设置成一致即可。indicatorLineMarginTop：其为TabView下的导航条的上边距。indicatorLineMarginBottom：其为TabView下的导航条的下边距。indicatorLineScrollMode：其为TabView下的导航条的滚动模式，共有两种1、dynamic：即爱奇艺/腾讯视频那种可变化长度的效果。导航条长度、位置均变化。2、transform：普通移动效果，导航条长度不变，位置变化。四、自定义TabView(即自定义指示器的Item的样式)1、创建一个类继承PagerTabView，重写initPagerTabView()方法去将自定义的View加入PagerTabView。并复写getTitleTextView()返回自定义View的TextView（该TextView用于显示指示器的标题，必不可少）。123456789101112131415161718192021222324252627public class CustomPagerTabView extends BasePagerTabView &#123; private TextView mTextView; public PagerTabView(Context context) &#123; super(context); &#125; public PagerTabView(Context context, @Nullable AttributeSet attrs) &#123; super(context, attrs); &#125; public PagerTabView(Context context, @Nullable AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); &#125; @Override public TextView getTabTextView() &#123; return mTextView; &#125; @Override public View onCreateTabView(Context context) &#123; mTextView = new TextView(context); return mTextView; &#125;&#125;2、创建一个类继承DynamicPagerIndicator并重写createTabView()。在createTabView()创建自定义的PagerTabView并将其设置给DynamicPagerIndicator。12345678910111213141516171819public class CustomPagerIndicator extends DynamicPagerIndicator &#123; public CustomPagerIndicator(Context context) &#123; super(context); &#125; public CustomPagerIndicator(Context context, AttributeSet attrs) &#123; super(context, attrs); &#125; public CustomPagerIndicator(Context context, AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); &#125; @Override public BasePagerTabView createTabView(PagerAdapter pagerAdapter, final int position) &#123; return new CustomPagerTabView(mContext); &#125;&#125;3、在xml中使用自定义的CustomPagerIndicator，属性设置和DynamicPagerIndicator无区别。123456789&lt;com.kcrason.dynamicpagerindicator.CustomPagerIndicator android:id="@+id/dynamic_pager_indicator5" android:layout_width="match_parent" android:layout_height="wrap_content" app:indicatorLineHeight="20dp" app:indicatorLineRadius="8dip" app:indicatorLineScrollMode="dynamic" app:pagerIndicatorMode="fixed" /&gt;设置监听1、设置单个TabView点击监听：通过DynamicPagerIndicator的对象设置OnItemTabClickListener即可。123456dynamicPagerIndicator.setOnItemTabClickListener(new DynamicPagerIndicator.OnItemTabClickListener() &#123; @Override public void onItemTabClick(int position) &#123; Toast.makeText(this, "you click " + position, Toast.LENGTH_SHORT).show(); &#125; &#125;);2、设置ViewPager的监听，由于DynamicPagerIndicator内部已经设置了ViewPager的监听，所以外部如果需要ViewPager的监听，需要用到新的接口OnOutPageChangeListener。1234567891011121314151617181920212223242526272829303132333435dynamicPagerIndicator.setOnOutPageChangeListener(new DynamicPagerIndicator.OnOutPageChangeListener() &#123; @Override public void onPageScrolled(int position, float positionOffset, int positionOffsetPixels) &#123; &#125; @Override public void onPageSelected(int position) &#123; &#125; @Override public void onPageScrollStateChanged(int state) &#123; &#125;&#125;); 或者通过实现内部静态类 dynamicPagerIndicator1.setOnOutPageChangeListener(new DynamicPagerIndicator.SimpleOnOutPageChangeListener()&#123; @Override public void onPageScrollStateChanged(int state) &#123; super.onPageScrollStateChanged(state); &#125; @Override public void onPageSelected(int position) &#123; super.onPageSelected(position); &#125; @Override public void onPageScrolled(int position, float positionOffset, int positionOffsetPixels) &#123; super.onPageScrolled(position, positionOffset, positionOffsetPixels); &#125;&#125;);注意事项务必先给viewPager设置adapter之后再将ViewPager对象设置给DynamicPagerIndicator版本更新1.5.0修复部分bug。1.1.0添加是否显示为粗体添加字体滑动大小过程渐变。修复部分bug,优化使用体验。1.0.6修复某些情况下tab字体颜色出现不一致的情况。1.0.4修复若干bug。修改Indicator数量动态更新问题。1.0.3增加pagerIndicatorScrollToCenterMode模式选择,意为导航条滚动居中的模式。该模式只针对pagerIndicatorMode=scrollable时有效。共有两种，第一种为linkage(联动模式)：滑动页面时，整个导航栏同步移动到居中的位置。第二种为transaction(异动模式)：滑动页面完整后，才将需要居中显示的栏目滑动的居中的位置。修改更新TabView数量的方法为updateTabView(),不再使用createOrUpdateTabView(ViewPager viewpager)去更新TabView的数量。1.0.2增加tabTextColorMode模式选择，共有两种。第一种为common，即普通文字变化模式。第二种为gradient，即从未选中的颜色渐变到选中的颜色。TabView的数量可动态配置。配合ViewPager+Fragment(多个)动态更新时的情况。当需要更新TabView的数量时。使用DynamicPagerIndicator对象的去调用createOrUpdateTabView(ViewPager viewpager)即可。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>indicator</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一张图带你深入了解Handler机制]]></title>
    <url>%2F2017%2F12%2F06%2F%E4%B8%80%E5%BC%A0%E5%9B%BE%E5%B8%A6%E4%BD%A0%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3Handler%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[前言这两天正好闲着，遂回顾了一下以前觉得理解的很模糊的东西。Handler机制便是其中之一。尽管我们经常用Handler进行线程之间的通信。但是对其中的过程，可能没太怎么去了解。即便有了解，可能也被复杂的逻辑给整蒙了。又是Looper又是MessageQueue的。我就是被整蒙圈的一员。但是今天，我将它重新梳理了一遍，在此记录一下。一方面是便于以后查看，另一方面加深自己的理解。Handler机制思维导图先上一张我画的思维导图，通过这张图，你就能清晰明了的了解Handler，Looper、Message、MessageQueue它们之间的千丝袜缕了。该图比较大，建议在电脑上观看效果会更好。https://github.com/KCrason/kcrason.github.io/blob/master/uploads/images/Handler%E6%9C%BA%E5%88%B6.pngHandler机制流程分析流程概述首先，我们知道，通常在Android Activity中使用Handler的流程是：创建Handler对象-&gt;在异步线程中使用Handler对象发送消息。然后就能在Handler的回调中收到消息。而事实上Handler机制的起始并不是从创建Handler对象开始，而是从Looper.preare()开始的。之后还要调用Looper.loop()整个过程才算真正完成。在Activity之所以看不到Looper相关的代码，是因为主线程已经做了。ActivityThread(主线程)的main方法源码12345678910111213141516171819public static void main(String[] args) &#123; SamplingProfilerIntegration.start(); ...省略部分代码 //初始化Looper Looper.prepareMainLooper(); ActivityThread thread = new ActivityThread(); thread.attach(false); ...省略部分代码 Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); //开始循环取消息 Looper.loop(); throw new RuntimeException("Main thread loop unexpectedly exited"); &#125;而你在异步线程中使用Handler，它应该是下面这样的逻辑：12345678910111213141516new Thread(new Runnable() &#123; @Override public void run() &#123; //初始化Looper Looper.prepare(); //创建Handler对象 Handler handler = new Handler(new Handler.Callback() &#123; @Override public boolean handleMessage(Message msg) &#123; return false; &#125; &#125;); //开始循环取消息 Looper.loop(); &#125; &#125;).start();知道了使用规则，那么下面我们根据这个规则来分析它们之前的联系。初始化Looper调用Looper.preare()或Looper.prepareMainLooper方法开始，就是创建Looper对象的起点。那么在Looper.preare()中到底干了啥呢。我们看源码：12345678910public static void prepare() &#123; prepare(true);&#125;//quitAllowed是否允许终止循环取消息。private static void prepare(boolean quitAllowed) &#123; if (sThreadLocal.get() != null) &#123; throw new RuntimeException(&quot;Only one Looper may be created per thread&quot;); &#125; sThreadLocal.set(new Looper(quitAllowed));&#125;可以看到，很简单，就是 new了一个Looper。然后将Looper对象设置进sThreadLocal。sThreadLocal是Looper类的一个常量对象，其在在Looper类中的声明：1static final ThreadLocal&lt;Looper&gt; sThreadLocal = new ThreadLocal&lt;Looper&gt;();我们接着看Looper的构造函数：123456private Looper(boolean quitAllowed) &#123; //创建一个MessageQueue赋值给mQueue mQueue = new MessageQueue(quitAllowed); //获取当前线程赋值给mThread mThread = Thread.currentThread();&#125;至此，Looper的初始化工作完成。神奇的ThreadLocal之所以说ThreadLocal很神奇，是因为它确实很神(好像是废话~)，它的神奇之处在于同一个ThreadLocal对象它可以在不同的线程间的赋值互不影响。什么意思呢？例子说明：123456789101112131415161718192021222324252627282930313233private void testTreadLocal() &#123; //创建ThreadLocal对象 final ThreadLocal&lt;String&gt; threadLocal = new ThreadLocal&lt;&gt;(); Thread oneThread = new Thread(new Runnable() &#123; @Override public void run() &#123; //oneThread设置值OneThreadValue threadLocal.set(&quot;OneThreadValue&quot;); //打印oneThread下的结果 Log.i(&quot;KCrason&quot;, &quot;testTreadLocal: &quot; + threadLocal.get()); &#125; &#125;); Thread twoThread = new Thread(new Runnable() &#123; @Override public void run() &#123; //twoThread设置值TwoThreadValue threadLocal.set(&quot;TwoThreadValue&quot;); //打印twoThread下结果 Log.i(&quot;KCrason&quot;, &quot;testTreadLocal: &quot; + threadLocal.get()); &#125; &#125;); oneThread.start(); twoThread.start(); //主线程中设置值MainThreadValue threadLocal.set(&quot;MainThreadValue&quot;); //打印mainThread下结果 Log.i(&quot;KCrason&quot;, &quot;testTreadLocal: &quot; + threadLocal.get()); &#125;输出结果：通过输出结果，我们知道，其实ThreadLocal就是对不同线程的赋值拷贝了一个副本进而保存了。到此，我相信对于ThreadLocal，你已经能够理解了，至于它具体是如何实现的，这里暂不分析，你也可以去查看源码进行深入了解。Handler的创建同Looper一样，我们来照样从构造函数开始分析Handler的创建，看它到底干了啥？首先，Handler有多个构造函数，但它们无一例外的都会回到下面两个构造函数中来。1234567891011public Handler(Callback callback, boolean async) &#123; ...省略部分代码 mLooper = Looper.myLooper(); if (mLooper == null) &#123; throw new RuntimeException( &quot;Can&apos;t create handler inside thread that has not called Looper.prepare()&quot;); &#125; mQueue = mLooper.mQueue; mCallback = callback; mAsynchronous = async;&#125;123456public Handler(Looper looper, Callback callback, boolean async) &#123; mLooper = looper; mQueue = looper.mQueue; mCallback = callback; mAsynchronous = async;&#125;事实上，通过比较，我们发现他们俩干的事其实都是一样的。那都干啥了呢，分为两种情况：1、如果有传递Looper，那么直接将传递的Looper对象赋值给mLooper。2、如果没有传递Looper，则通过Looper.myLooper()获取Looper对象。然后赋值给mLooper。前面我们提到初始化Looper时会将创建的Looper对象保存在Looper的sThreadLocal中，而Looper.myLooper()正是通过sThreadLocal去获取了在该线程下的Looper对象。12345Looper中的myLooper方法源码public static @Nullable Looper myLooper() &#123; //通过sThreadLocal的get()返回创建的Looper对象。 return sThreadLocal.get();&#125;与此同时，通过获取到的mLooper 对象去获取在Looper中创建的MessageQueue对象并赋值给Handler的变量mQueue，最后将Callback对象进行赋值。Handler的初始化完成。Looper.loop()开启循环获取消息事实上，在初始化Looper之后，就可以直接调用Looper.loop()进行循环取消息进行处理。只不过那时MessageQueue中还没有消息，循环就处于block状态罢了。我们看loop()方法源码：12345678910111213141516171819202122232425262728public static void loop() &#123; final Looper me = myLooper(); if (me == null) &#123; throw new RuntimeException(&quot;No Looper; Looper.prepare() wasn&apos;t called on this thread.&quot;); &#125; final MessageQueue queue = me.mQueue; ...省略部分代码 for (;;) &#123; Message msg = queue.next(); // might block if (msg == null) &#123; // No message indicates that the message queue is quitting. return; &#125; ...省略部分代码 try &#123; msg.target.dispatchMessage(msg); end = (slowDispatchThresholdMs == 0) ? 0 : SystemClock.uptimeMillis(); &#125; finally &#123; if (traceTag != 0) &#123; Trace.traceEnd(traceTag); &#125; &#125; ...省略部分代码 msg.recycleUnchecked(); &#125; &#125;其流程简单来讲，就是通过一个死循环使用MessageQueue的next()方法不断的从MessageQueue中取出消息，如果为null，则block。否则，通过msg.target.dispatchMessage(msg)将消息分发。你可能会有所疑问，msg.target又是个什么鬼？没关系，我们接着往下分析。使用Handler发送消息首先，在使用Handler发送消息时，不管是哪种方式，最终都会调用sendMessageAtTime()方法，其中mHandler.post(Runnable runnable)也是先将runnable封装成一个Message最后调用sendMessageAtTime()，根据源码分析：1234567//将runable封装到Message中private static Message getPostMessage(Runnable r) &#123; Message m = Message.obtain(); //将Runnable对象r赋值给Message的callback变量。 m.callback = r; return m;&#125;1234567891011//发送消息public boolean sendMessageAtTime(Message msg, long uptimeMillis) &#123; MessageQueue queue = mQueue; if (queue == null) &#123; RuntimeException e = new RuntimeException( this + &quot; sendMessageAtTime() called with no mQueue&quot;); Log.w(&quot;Looper&quot;, e.getMessage(), e); return false; &#125; return enqueueMessage(queue, msg, uptimeMillis);&#125;在sendMessageAtTime()中，我们注意到，其最后调用了enqueueMessage()，下面我们看enqueueMessage()又干了什么。123456789private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) &#123; //将Handler对象赋值给msg.target msg.target = this; if (mAsynchronous) &#123; msg.setAsynchronous(true); &#125; //将消息加入到MessageQueue(消息队列) return queue.enqueueMessage(msg, uptimeMillis);&#125;从enqueueMessage()中，我们知道了上面那个msg.target是个啥了，它其实就是当前的Handler对象。queue.enqueueMessage()即真正意义上的将Message加入到消息队列中。最后通过Handler对象的dispatchMessage()方法，最终将消息回调出来。最后我们再看看dispatchMessage()中干了啥：123456789101112public void dispatchMessage(Message msg) &#123; if (msg.callback != null) &#123; handleCallback(msg); &#125; else &#123; if (mCallback != null) &#123; if (mCallback.handleMessage(msg)) &#123; return; &#125; &#125; handleMessage(msg); &#125;&#125;显示判断msg.callback是否为null，而msg.callback实际上就是使用mHandler.post(Runnable r)发送的Runnable的对象。1、如果msg.callback不为null，调用handleCallback，而handleCallback就是调用了msg.callback.run()2、如果msg.callback为null，再判断是否设置了Callback接口，设置了回调Callback接口中的handleMessage()，没有设置直接回调Handler的空方法handleMessage()。至此，整个流程结束。一些疑问尽管，通过上面的分析，我相信你对Handler的机制已经有了更深的理解。但是一直以来，有两个问题依然深深的困扰着我。1、Handler究竟是如何进行不同线程切换的？上面我们提到，通常而言，我们会使用Handler在异步线程中发送消息，之后都会调用enqueueMessage()方法将消息加入到消息队列中，而我们所使用的MessageQueue对象却是来源MainThread(主线程)中Looper所创建的。也就是说，Handler发送消息时，MessageQueue的对象是运行在异步线程中的。而使用Looper.loop()开启循环后，MessageQueue的对象是运行在MainThread(主线程)的。这也是为什么在enqueueMessage()中，将消息加入到消息队列需要增加synchronized关键字，因为我们需要确保MessageQueue对象在同一时刻只能有一个线程访问。这一点，在MessageQueue#enqueueMessage()的源码得到验证：123456789101112131415161718192021boolean enqueueMessage(Message msg, long when) &#123; if (msg.target == null) &#123; throw new IllegalArgumentException(&quot;Message must have a target.&quot;); &#125; if (msg.isInUse()) &#123; throw new IllegalStateException(msg + &quot; This message is already in use.&quot;); &#125; //注意这里的synchronized字段的作用。 synchronized (this) &#123; if (mQuitting) &#123; IllegalStateException e = new IllegalStateException( msg.target + &quot; sending message to a Handler on a dead thread&quot;); Log.w(TAG, e.getMessage(), e); msg.recycle(); return false; &#125; ...具体的加入到队列的逻辑我们不分析，省略该部分代码 &#125; return true; &#125;通过上面的分析，我们可以得出结论：Handler的不同线程数据传输其实就是通过共享变量来实现的，而他们之间的介质便是Message。2、view.post(Runnable runable)和mHandler.post(Runnable runnable)之间的关联是什么？为何在Activity的onCreate()中调用view.gitHeight()返回0，而使用view.post(Runnable runable)之后可以正确的返回View的高度？关于这个问题，我将会用另一篇文章来单独分析~Welcome to KCrason’s blog]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>handler机制</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo+NexT+GitHub简易建站流程]]></title>
    <url>%2F2017%2F12%2F04%2FHexo%2BNexT%2BGitHub%E7%AE%80%E6%98%93%E5%BB%BA%E7%AB%99%E6%B5%81%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[一直以来，我都急切的渴望拥有一个属于自己的博客网站，但是两年来，由于各种原因一直没能是真正的实践。正好这几天闲了下来，无意中看他人博客时发现了个人建站的曙光。温馨提示：该网站使用Hexo+NexT+GitHubPage构建，如果你已了解并成功建立了自己的网站，那么请及时下车，免得耽误您的时间。如果你还不了解并用建站的渴望，那么接着往下看。下面开始开车啦…先打个广告哈，这是我刚建的网站：Welcome to KCrason’s blog ，期待大佬们的践踏！搭建环境安装git客户端。鉴于git客户端在国内的下载速度慢的感人，在此提供一个超快的下载地址。传送门安装Node.js。这里只要直接从官网首页下载他的.exe的文件直接安装即可。安装Hexo。安装Hexo需要使用Git Bash，因此先找到刚才安装的git客户端找到Git Bash并打开。1、输入$ npm install -g hexo-cli，该命令为在本地安装Hexo。2、在任意一个盘中的任意位置建立一个文件夹，名称随便取，最好为youname.github.io。比如我在D盘建立了一个名为kcrason.github.io的文件夹。3、复制你创建的文件夹地址，接着在Git Bash中输入$ hexo init D:\kcrason.github.io（注意，将路径该成你自己的）。该命令将会复制建站所需文件，并初始化相关建站参数。这个过程为需要网络，耐心登录片刻。4、接着，输入$ cd D:\kcrason.github.io命令。5、最后，输入$ npm install命令。6、输入$ hexo g，该命令用于生成静态文件。7、输入$ hexo s，改命令为启动Hexo服务。8、在浏览器输入：localhost:4000，回车，出现下面这个界面，恭喜你，成功了三分之一了。Hexo安裝NexT主題Hexo的默认主题为landscape。本教程将使用另一款现极为流行的主题NexT为基础。后续的主题相关配置都是基于NexT的。如果你要建站，我也强烈建议你使用该主题。安装步骤并切换至NexT主题1、使用Git Bash输入$ cd D:\kcrason.github.io进入网站文件夹。2、接着输入$ git clone https://github.com/iissnan/hexo-theme-next themes/next克隆最新版本的Next主题。当然你也可以使用稳定版，详情请查看官网。下载会有点慢哦，别着急~3、使用Notepad++/Sublime Text打开站点配置文件，即\kcrason.github.io\_config.yml文件。找到 theme字段，并将其值由默认的landscape更改为next。4、输入$ hexo g，重新生成静态文件。5、输入$ hexo s，启动Hexo服务。6、再次输入在浏览器输入：localhost:4000，回车。这时候你会看到你的网站界面已经是下面这样啦。Hexo站点配置和主题配置Hexo的配置包括多个部分，广义上来说主要是Hexo本身的配置和Hexo主题的配置。Hexo本身配置主要在\kcrason.github.io\_config.yml配置。而主题的配置则在\kcrason.github.io\themes\next\_config.yml配置。其中，以主题配置为主。Hexo站点配置Hexo站点的配置是在\kcrason.github.io\_config.yml文件中进行的，其一般包括以下几个部分，自行根据需求修改站点配置文件当中的值。Hexo主题配置Hexo的主题配置是在\kcrason.github.io\themes\next\_config.yml文件进行配置，主题的配置包括多个方面。这方面的配置查看NexT的官方文档即可。将Hexo站点托管至GitHub在GitHub创建一个新的repository，名称为：youname.github.io站点部署1、打开Git Bash，输入$ npm install hexo-deployer-git --save。该命令用于安装hexo-deployer-git。目的是将本地和Hexo网站部署到刚刚在GitHub创建的repository中。2、打开\kcrason.github.io\_config.yml，找到其中的deploy字段。修改和增加如下内容。1234deploy: type: git repo: https://github.com/KCrason/kcrason.github.io.git（你自己的在GitHub的repository地址） branch: master3、在Git Bash中输入$ hexo clean &amp;&amp; hexo g &amp;&amp; hexo d命令。该命令为三条命令的合并：清理本地缓存-&gt;重新编译生成静态页面-&gt;上传站点内容至GitHub仓库。4、此时在浏览器输入：https://youname.github.io就能访问了。比如我的为https://kcrason.github.io。至此，免费的个人博客算是完成了，如果你想使用自己的域名。那么就要花一点钱买一个域名了。下面讲如何将现有的站点绑定自己购买的域名。将Hexo站点绑定新的域名域名购买1、本人是在阿里的万网上购买的，阿里巴巴还是不错的。现在买.com域名送一个.xyz的域名。成功购买域名后，先在站点的source路径下建立一个名为CNAME的文件，比如我的路径为D:\kcrason.github.io\source。注意文件名称必须大写。然后在文件中填写你的域名（去掉前面的www）。如：我申请的域名为：www.kcrason.com，就只要在文件中填写kcrason.com即可。2、打开Git Bash，输入$ hexo d命令，将CNAME上传到GitHub的仓库中。域名解析打开阿里云后台，打开你所购买的域名列表，点击指定域名右边的解析。然后添加解析。第一个解析，记录类型选择CHAME，主机记录为@，记录值为youname.github.com（也就是你所建立的站点域名）。其他默认即可。再次点击添加解析，记录类型选择CHAME，主机记录为www，记录值为youname.github.com（也就是你所建立的站点域名）。其他默认即可。最后，等待几分钟，输入新的域名，发现可以访问啦！]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于bugly热更新集成和使用的一些坑]]></title>
    <url>%2F2017%2F08%2F26%2F%E5%85%B3%E4%BA%8Ebugly%E7%83%AD%E6%9B%B4%E6%96%B0%E9%9B%86%E6%88%90%E5%92%8C%E4%BD%BF%E7%94%A8%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9D%91%2F</url>
    <content type="text"><![CDATA[对于android开发而言，现在热更新技术可以说是比较火热，当然，就国内环境而言，热更新的技术主要由阿里和腾讯两大阵营，尽管他们实现方式不同，也各有优缺点，但是目标都是一致的，就是希望能够带来技术上得革新，以及方便广大开发者更有效率的开发android应用。而具体的一些热更新框架的比较，在此不做赘述，网上有太多这样比较博客了。由于我们项目之前有用到bugly去统计一些崩溃和ANR，因此，当产品说，我们也需要热更新时，嗯，为了方便那还是就用bugly的热更新吧。毕竟方便，评价也还不错。bugly热更新框架是基于微信的Tinker的，而具体的集成过程，bugly官网也有相应的文档。按照开发文档的介绍，基本上没啥问题。然而，有一些坑，仍然是我们所需要去解决的。一，基准包和补丁包刚开始的时候，我也是一脸懵逼，又是基准包又是补丁包的，就不能一次解决吗？没办法，现实就是这样，遇到很多问题，除了自己硬着头皮上，没人可以真正帮你什么。所谓的基准包：和我们普通的签名验证的包是一致的，唯一的不同是，我们需要使用app-&gt;tasks-&gt;build-&gt;assembleRelease命令去生成基准包，具体路径看图。使用该命令后，生成的基准包的位置就在… 看图注意：生成基准包时要改tinker-support.gradle文件中的tinkerId，关于这个字段的命名，因人而异，保证唯一就行。打完基准包之后，再使用什么加固啊，然后上传应用市场即可。接下来我们再看补丁包，补丁包需要基准包的支持。首先修改tinker-support.gradle的baseApkDir，即你打基准包生成的文件夹的所有内容，这也是为什么要保存这个文件夹的原因。因为上线版本出现了问题，就要依靠这个基本包文件夹中的所有内容去生成补丁包。其次，修改tinker-support.gradle中的tinkerId，同样的，需要保证其唯一性。修改完成后，使用tinker-support中的buildTinkerPatchRelease命令生成补丁包。生成补丁包的位置如下：最后，在bugly后台发布补丁包即可。需要注意的是，发布补丁包之前，需要对基准包联网上报相关信息。否则，发布补丁包时，无法匹配到相对于的基准包版本信息。二，大坑按照标准的流程走，确实没啥问题。可是，就在鼓舞欢庆时，出现了问题。根据bugly崩溃统计。大量的android sdk为23的设备出现进入app即崩溃的现象。查看崩溃日志发现了一个错误：java.lang.ArithmeticException error:0f06707b:elliptic curve routines:EC_GROUP_new_by_curve_name:UNKNOWN_GROUP，具体的调用栈为而且，该错误只出现在Android sdk版本为23的手机上，找了bugly技术客服，无果。google，百度，无果。后经过两天的反复测试和验证。找了问题产生的地方。由于我们项目之前集成过腾讯IM SDK，在对IM SDK进行初始化时调了改行代码1TIMManager.getInstance().init(getApplicationContext(), Constants.SDK_APPID, Constants.ACCOUNT_TYPE);从而导致了Tinker热更新时，在进行补丁包插入时，出现了问题。该问题的具体原因为系统方法时调用了123456789101112public static BigInteger valueOf(long value) &#123; if (value &lt; 0) &#123; if (value != -1) &#123; return new BigInteger(-1, -value); &#125; return MINUS_ONE; &#125; else if (value &lt; SMALL_VALUES.length) &#123; return SMALL_VALUES[(int) value]; &#125; else &#123;// (value &gt; 10) return new BigInteger(1, value); &#125; &#125;最终在BigInt类中的makeValid方法中崩溃。再往下查看，发现BN_new为natvie方法。我的天啊。最后，虽然问题是找到了，但是其基本原因还不知道，为什么调用了IM SDK的初始化方法会出现这样的问题暂时不得而知，希望通过这篇文章能给遇到相同问题的朋友一些解决思路。也希望知道根源的朋友能够给我留言。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>bugly</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一行代码解决Android6.0及以上版本权限申请问题。]]></title>
    <url>%2F2017%2F08%2F23%2F%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%E8%A7%A3%E5%86%B3Android6.0%E5%8F%8A%E4%BB%A5%E4%B8%8A%E7%89%88%E6%9C%AC%E6%9D%83%E9%99%90%E7%94%B3%E8%AF%B7%E9%97%AE%E9%A2%98%E3%80%82%2F</url>
    <content type="text"><![CDATA[众所周知，从android sdk 23开始，android就改变了权限的管理模式。对于一些涉及用户隐私的权限则需要用户的授权才可以使用。在此之前，开发者只需要在AndroidManifest中注册权限即可，但是现在除了注册还需要进行手动的授权。对于很多开发者来说，这一步似乎挺麻烦的，但是又不得不做。今天我要记录的正是如何通过最简单有效的方式来解决这个让人心烦的问题。首先我们需要了解权限申请的几个相关方法。项目地址：https://github.com/KCrason/PermissionGranted.git项目演示：######一，请求权限的方法1ActivityCompat.requestPermissions(final @NonNull Activity activity,final @NonNull String[] permissions, final @IntRange(from = 0) int requestCode)从该方法可以看出，可以一次申请多个权限，多个权限由数组构成。而后面的requestCode则是权限请求的请求码，该字段在请求结果处理的方法1######二，检查是否已经授权相关权限ContextCompat.checkSelfPermission(@NonNull Context context, @NonNull String permission)12从该方法的参数上来看，只能接收单个的权限，然后再去判断是否已经授权，该处判断是否已经授权主要是看```checkSelfPermission```方法返回的常量值是否等于```PackageManager.PERMISSION_GRANTED```，如果不等于该值，则说明当前所需的权限还没有进行用户授权，此时需要进行用户授权。######三，检查是否需要提示用户对该权限的授权进行说明，返回boolean类型ActivityCompat.shouldShowRequestPermissionRationale(@NonNull Activity activity, @NonNull String permission)123关于这个方法，网上一直有很多争论，这个方法到底该怎么用，刚开始我也是一头雾水，因为本身官方API的用意是希望该方法在弹出一次权限后，如果用户拒绝，再次弹出授权时先给用户一个说明（也就是为什么我要用这个权限）。此时的返回值为true。但是据说国内的很多OS都是直接返回false。这里就不吐槽国内OS云云了，直接说怎么办吧，在该处的处理是直接提示到设置界面进行开启授权。######四，权限的授权回调结果@Overridepublic void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) {……}12345该方法就是在进行用户授权后，用户反馈的结果回调。不管是成功还是失败，都会在这里有一个回调结果，同样的，返回的结果也是一个int型的数组```grantResults```，该值保存的就是前面讲到的```PackageManager.PERMISSION_GRANTED```，而requestCode就是```requestPermissions```方法中的requestCode。需要注意的是，由于该方法是```FragmentActivity```的一个方法。因此，对于回调的结果就必然要在```FragmentActivity```类或器子类中进行处理。---好了，重要的方法已经讲完了，接下来讲一下如何既能简单快捷封装，又不影响外部调用者的便捷。前面讲到，既然回调的方法需要在```FragmentActivity```或其子类中，那么索性就将所有的请求处理全部交由```AppCompatActivity```，我们构建了一个名称为PermissionActivity的类，该类专门用于处理权限相关的内容，同时，这个activity的主题应该设置为透明。因为我们不能因为请求权限而影响其他的界面显示。所以我们给该activity设置的style为：123456，当我们需要请求某一个或者某一组权限的时候，我们通过Intent去传递即可。而请求权限的结果回调，则直接在发起请求的那个activity的```onActivityResult```中处理即可。其中PermissionActivity类具体的逻辑处理可以参考[源代码](https://github.com/KCrason/PermissionGranted.git)---最后，来看一下使用示例：比如我需要请求相机和录音权限- 第一步，发起请求startActivityForResult(new Intent(this, PermissionActivity.class).putExtra(PermissionActivity.KEY_PERMISSIONS_ARRAY,new String[]{Manifest.permission.CAMERA, Manifest.permission.RECORD_AUDIO}), PermissionActivity.CALL_BACK_PERMISSIO1- 第二步，处理结果。@Overrideprotected void onActivityResult(int requestCode, int resultCode, Intent data) {super.onActivityResult(requestCode, resultCode, data);if (requestCode == PermissionActivity.CALL_BACK_PERMISSION_REQUEST_CODE){switch (resultCode){case PermissionActivity.CALL_BACK_RESULT_CODE_SUCCESS:Toast.makeText(this,”权限申请成功！”,Toast.LENGTH_SHORT).show();break;case PermissionActivity.CALL_BACK_RESULE_CODE_FAILURE:Toast.makeText(this,”权限申请失败！”,Toast.LENGTH_SHORT).show();break;}}}当然，现在网络上不乏有很多框架来处理这个问题，但是我认为，很多时候，作为一个开发者，能尽量少用框架的时候就尽量少用，能自己写总比老想着用别人的好，想想在一个项目中加那么多compile不觉得后背发凉么？O(∩_∩)O哈哈~]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android权限</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css margin属性理解与使用]]></title>
    <url>%2F2016%2F10%2F18%2Fcss%20margin%E5%B1%9E%E6%80%A7%E7%90%86%E8%A7%A3%E4%B8%8E%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[最近应公司需要，暂转为前端学习-开发。确实，最近前端因为一个“小程序”被炒得热火朝天。当然这并不意味着从此脱离了Android，简书依然会记录一些Android学习-开发的心路历程，当然以后不再是单纯的Android文章了，可能还包括web在内的一些其他开发知识的记录。在css中，margin的使用和android中的使用有着很大的不一样，尤其在做过android开发之后再去接触css，俨然有种要崩溃的感觉。但是没办法。这都是命~css中普通元素之间设置margin好像并无不妥，但是在css中，这一切远没有那么简单。#####1、关于垂直外边距合并问题：导致这一问题的根本原因是上下元素之间没有设置界限限制，因此在给下面的元素设置margin之后，其父元素会跟随移动。为了更为形象的说明这其中的关系，这里引用w3cSchool的图片#####2、关于元素的居中css中可以通过设置左右margin来使自身居中（注意这里是指元素本身，而且当前元素为block）123div&#123; margin 0 auto;&#125;而如果要使得div内居中，则需要通过设置text-align和vertical-align，其中vertical-align在设置line-height之后起作用。#####3、对于一些元素而言，其默认是有边距的，那么为了消除其边界距离，我们通过需要设置margin padding 或者border为0来解决。]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[View的三种移动方式]]></title>
    <url>%2F2016%2F09%2F13%2FView%E7%9A%84%E4%B8%89%E7%A7%8D%E7%A7%BB%E5%8A%A8%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[Android开发中，View一直是Android开发人员的一块心病，一方面想要进阶，一方面又害怕进阶，可以说Android的View是进阶路上的最大绊脚石，因为它涉及的东西太多了，比如本次我们此次要写的View移动，另外还包括View的触摸事件的传递，创建自定义View，这些都是极其重要且不得不面对的难题。但是无论如何，现在不克服的困难将来就会被困难克服。啊，真是一波好鸡汤…####Let’s begin！在此之前，我们还是先了解Android坐标系的定义规则以及View的一些位置参数。View的位置及大小是由四个参数决定，即left、top、right、bottom，并且这四个参数都是相对于其父View的。12int width = right-left;int height = bottom-top;在Activity中布局完成后，我们可以通过View一些方法获取这些参数信息：12345//left,top,right,bottom值的获取int left = getLeft();int top = getTop();int right = getRight();int bottom = getBottom();另外Android 3.0以后加入x，y，translationX，translationY等参数。（x,y）表示为View在ViewGroup中左上角的x,y的值，translationX，translationY在用于平移一个View。默认是都为0，在调用了View的setTranslationX()/setTranslationY()之后发生改变。12345//x,y,translationX,translationY参数的获取int x = getX();int y = getY();int translationX = getTranslationX();int translationY = getTranslationY();PS：调用View的setTranslationX()和setTranslationY()方法虽然可以使得View平移指定距离，但是这一过程是瞬间完成的。为了使View的移动使得更为平滑，因此可以使用View的属性动画来指定translationX和translationY。123ObjectAnimator valueAnimator = ObjectAnimator.ofFloat(textView, &quot;translationX&quot;, 200);valueAnimator.setDuration(2000);valueAnimator.start();另外，如果给View设置setTranslationX()和setTranslationY()后，如果设置的值没有发生变化，那么其只会移动一次，即首次指定的移动距离。查看源码后我们发现原因：原来在设置值之后其会将设置进去的值和当前的translationX，translationY进行对比，不一致时才进行移动。了解了View的一些基本参数之后，我们看关于View的三种移动方式。#####一、使用Android系统提供的scrollTo()/scrollBy()方法实现View的移动。不管是scrollTo()还是scrollBy()其移动的本质都是View/ViewGroup中的内容。并且其移动的过程是瞬间完成的，因此，为了实现更好的移动效果，他需要与Scroller类结合使用。另外，它不同于上面的Translation，移动的是View本身，这一点需要好好理解一下。scrollTo()和scrollBy()都是View中的方法，不是Scroller中的方法，但是控制View的平滑移动与Scroller类密不可分。*scrollTo() : *指是的移动的绝对位置，如果位置没有变化，多次调用则不会起作用。*scrollBy() : *其本质依然是调用的scrollTo()，指的的移动当前位置的相对距离（每次都是先将当前的位置和设置的距离相加之和调用scrollTo()，这样如果你多次调用，你就会发现其每次都会移动一段距离，这是和scrollTo()的本质区别）PS:关于上面两张图，其实一直以来，我自己都没完全搞明白什么相对绝对，所以两张手图可能会让人更容易理解。还有就是scrollTo()和scrollBy()移动方向问题，上面我们已经画过Android的坐标系，x轴左→右为正，y轴从上→下为正。但是这并不适用于scrollTo和scrollBy，scrollTo和scrollBy刚好相反，即x轴左→右为负，y轴从上→下为负，简直是有点坑爹啊。O__O “…Scroller类分析：而为什么使用Scroller类中的方法可以对View/ViewGroup的内容进行移动呢？下面我们试着分析一下。首先我们创建一个Scroller类的对象mScroller。然后要使View在规定的时间中移动到指定的位置，我们会调用startScroll()方法，startScroll()是Scroller类中的方法，另外Scroller类中还有一个filing()方法也是很常用的，它主要是处理平滑的移动，一般营造滑动之后的惯性效果，使得View的移动更逼真。下面我们看startScroll()的源码：1234//其接收四个/五个参数。如果duration不设置，则为默认。这四个参数都不难理解，这里不再做解释。 public void startScroll(int startX, int startY, int dx, int dy, int duration) &#123; ... &#125;而一般我们调用这个方法后都要去调View的 invalidate()，这个方法可以触发View的draw()方法。而draw()中调用了 computeScroll()，源码中我们发现computeScroll()是个空方法，这也是为什么我们需要重写 computeScroll()方法的原因。因为正在的移动操作就是在computeScroll()中进行的。123456789@Overridepublic void computeScroll() &#123; if (mScroller.computeScrollOffset()) &#123; scrollTo(mScroller.getCurrX(), mScroller.getCurrY()); //必须调用View的postInvalidate()/invalidate()，如果不加会导致View的移动只会第一帧。 postInvalidate(); &#125; super.computeScroll();&#125;上面我们看到Scroller类中还有一个computeScrollOffset()方法，它又是干啥的呢？它的主要作用就是判断mCurrX，和mCurrY是否有改变，有则返回true，无则返回false。通过这个方法的判断可以指点是否需要持续的调用scrollTo()去移动View。这里再给出一个示例，使用scrollTo()让View跟着手指移动：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485public class CuView extends LinearLayout &#123; private float mStartX; private float mStartY; private Scroller mScroller; /** * 第一次滑动是否完成 */ private boolean isFirstFinish; public CuView(Context context) &#123; super(context); init(context); &#125; public CuView(Context context, AttributeSet attrs) &#123; super(context, attrs); init(context); &#125; private void init(Context context) &#123; mScroller = new Scroller(context); &#125; public CuView(Context context, AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); init(context); &#125; @TargetApi(Build.VERSION_CODES.LOLLIPOP) public CuView(Context context, AttributeSet attrs, int defStyleAttr, int defStyleRes) &#123; super(context, attrs, defStyleAttr, defStyleRes); init(context); &#125; /** * 让View跟着你的手指走吧 * @param event * @return */ @Override public boolean onTouchEvent(MotionEvent event) &#123; int action = event.getAction(); switch (action) &#123; case MotionEvent.ACTION_DOWN: /** * 第一次移动完成后，我们不需要再去拿开始的位置了，否则造成View重新移动的最起始的位置。 */ if (!isFirstFinish) &#123; mStartX = event.getRawX(); mStartY = event.getRawY(); &#125; break; case MotionEvent.ACTION_MOVE: scrollTo((int) (mStartX - event.getRawX()), (int) (mStartY - event.getRawY())); break; case MotionEvent.ACTION_UP: //第一次移动完成 isFirstFinish = true; break; &#125; return true; &#125; /** * 测试startScroll */ public void startScroll() &#123; /** * 注意Scroller移动方向， */ mScroller.startScroll(20, 20, -500, -500, 5000); invalidate(); &#125; @Override public void computeScroll() &#123; if (mScroller.computeScrollOffset()) &#123; scrollTo(mScroller.getCurrX(), mScroller.getCurrY()); invalidate(); &#125; super.computeScroll(); &#125;&#125;#####二、使用动画实现View的移动。这里包括View的Tween Animation/Frame Animation，以及3.0之后加入的Property Animation。其移动的是View的一个映像，View本身的位置及大小并没有发生任何改变。#####三、设置View的LayoutParams来移动View123LinearLayout.LayoutParams layoutParams = (LinearLayout.LayoutParams) textView.getLayoutParams();layoutParams.leftMargin = 50;textView.requestLayout();]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android发布Library到JCenter]]></title>
    <url>%2F2016%2F09%2F02%2FAndroid%E5%8F%91%E5%B8%83%20Library%E5%88%B0JCenter%2F</url>
    <content type="text"><![CDATA[今天在尝试将最近写的一个小小的Library发布到JCenter，虽然早就闻JCenter的大名，但是一直没去做过这方面的尝试。第一次尝试，总得来说，遇坑不少，在此记录，也是希望后面的人能够一帆风顺！O(∩_∩)O哈哈~####一、项目的准备及配置首先，你得要待上传到jcenter的Library，比如我这里的randomtransformview。这一步之后，我们再进行对项目进行配置：对Project的Gradle的dependencies中加入classpath ‘com.novoda:bintray-release:0.3.4’在你需要上传的Module的gradle中添加apply plugin: ‘com.novoda.bintray-release’，注意不是app Module的Gradle。######随即在该Module的gradle下添加123456789publish &#123; userOrg = &apos;kcrason&apos;//bintray中的用户名 groupId = &apos;com.kcrason&apos;//根地址，一般是com.用户名 artifactId = &apos;randomtransformview&apos;//library名称 publishVersion = &apos;1.0.0&apos;//版本号，更新Library的时候只需要增加版本号即可。 desc = &apos;horizontal or vertical transform the view&apos;//描述，这个随意 //website：项目地址，一般项目都会上传github,这里给github的地址即可 website = &apos;https://github.com/KCrason/HorizontalTransformView&apos;&#125;一切都配好后点一下AS gradle右上角的sync new按钮，同步完成即可待传。####二、注册Bintary账号及建立Repository和Package关于注册Bintray账号，大家都知道，国内访问外网一直是个坑。对于不使用VPN或者更改hosts的用户来说，根本无法进入Bintray官网，已是深受其害。这里提供一个比较好的hosts给大家，一直都在用，配置之后大部分外网都能访问。1教程：在百度搜索关键词google hosts，百度之后你会发现第一个就是老D，没错，就是他。然后下载，里面有一个脚本，直接运行脚本就可以了。另外如果访问google，请使用这个地址：https://www.google.com.hk/YouTube上视频就不要瞎看了，更不要乱传播，自己心里清楚就好了，被查水表可不怪我哈。(⊙o⊙)…如果可以访问了，那么开始注册账号吧，这里不再细说，注册完成之后需要Create Repository(创建仓库)，如下：这里需要注意的是Type那个选项，我们选择maven，其他就可以随便填了。成功之后进入Repository，添加新的Package新添加的Package主要注意两个地方（下图已标识），一个是Name，一个是Version control，Name的名称和你Library名称相同，Version control就是你项目的存放的地址，比如我的就是在github上，https://github.com/KCrason/HorizontalTransformView到这里之后我们再来获取bintray分配给我们的API Key，上传项目的时候需要用到，点击Your Progile再点击可以看到API Key，复制以待后用####三、在Android Studio中上传项目至Bintray。上面的都完成之后我们回到项目。打开AS的命令行控制台，即Termialwindow系统下输入：(注意替换命令行中的PbintrayUser和PbintrayKey为自己的信息)1gradlew clean build bintrayUpload -PbintrayUser=your bintray username -PbintrayKey=your bintray api key -PdryRun=falseMAC下输入：1./gradlew clean build bintrayUpload -PbintrayUser=your bintray username -PbintrayKey=your bintray api key -PdryRun=false接下来就是持续的等待了，如果成功会在Terminal出现build sucessful的提示，在上传中可能会出现持续打点的过程，不用管，耐心等待就好。最后在Bintray对应的项目上，我们可以看到它，点击进去查看详情。最后add to jcenter通过审核之后就可以使用了，比如我上传的randomtransformview1compile &apos;com.kcrason:randomtransformview:1.0.0&apos;]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>JCenter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android SQLite]]></title>
    <url>%2F2016%2F08%2F18%2FAndroid%20SQLite%2F</url>
    <content type="text"><![CDATA[就当前的Android开发环境而言，做Android开发似乎变得越来越简单，的确，Android很容易上手，但是要深入理解并学好，却并不简单。从事Android开发一年来，本人最大的忧虑就是基础不扎实。尽管能胜任目前的工作。但是想要进阶，发现前路迷茫。人最怕的就是不知道自己想要什么，从而徘徊不前。额，好像扯远了，下面开始今天的重头戏，Android的小型数据库SQLite。Android的封装使得我们使用数据库变得方便快捷，尽管目前有很多开源的数据库框架供我们去使用，但是理解并使用原生Android系统所提供的API去构建数据库也是必不可少的。1、创建数据库，必不可少的需要一些固定的字段，表名，已经数据库名的一些常量的定义，在Android开发文档中，定义这些变量，推荐开发者自己创建一个标准的FeedEntry类，这是一个抽象的静态内部类，这个类implements BaseColumns类，在BaseColumms类中有定义两个字段，一个是_id以及_count，通常我们在创建数据库时都会定义一个自增的_id主键，因此，这样的方式，这显得更高逼格了。这里以创建一个评论数据表为例：123456789101112131415161718192021222324public class FeedEntry &#123; public FeedEntry() &#123; &#125; public abstract static class FeedEntryColumn implements BaseColumns &#123; //表名 public final static String TABLE_NAME = &quot;kcomment&quot;; //昵称 public final static String KEY_NAME = &quot;name&quot;; //评论内容 public final static String KEY_CONTENT = &quot;content&quot;; //是否是回复 public final static String KEY_REPLY = &quot;reply&quot;; //时间 public final static String KEY_TIME = &quot;time&quot;; //回复的内容 public final static String KEY_REPLY_CONTENT = &quot;reply_content&quot;; //头像 public final static String KEY_AVATAR = &quot;avatar&quot;; //信息 public final static String KEY_INFO = &quot;info&quot;; &#125;&#125;2、Android中使用SQLite我们需要创建一个class去继承SQLiteOpenHelper类，并实现SQLiteOpenHelper中的两个抽象方法onCreate()和onUpgrad()。123456789101112131415161718192021222324252627282930public class KDataBase extends SQLiteOpenHelper &#123; private final static String DATABASE_NAME = &quot;kcrason.db&quot;; private final static String SQL_CREATE_COMMENT_TABLE = &quot;CREATE TABLE IF NOT EXISTS &quot; + FeedEntry.FeedEntryColumn.TABLE_NAME + &quot; (&quot; + FeedEntry.FeedEntryColumn._ID + &quot; INTEGER PRIMARY KEY AUTOINCREMENT, &quot; + FeedEntry.FeedEntryColumn.KEY_NAME + &quot; VARCHAR(20), &quot; + FeedEntry.FeedEntryColumn.KEY_AVATAR + &quot; TEXT, &quot; + FeedEntry.FeedEntryColumn.KEY_CONTENT + &quot; TEXT, &quot; + FeedEntry.FeedEntryColumn.KEY_TIME + &quot; VARCHAR, &quot; + FeedEntry.FeedEntryColumn.KEY_REPLY + &quot; INTEGER, &quot; + FeedEntry.FeedEntryColumn.KEY_REPLY_CONTENT + &quot; TEXT, &quot; + FeedEntry.FeedEntryColumn.KEY_INFO + &quot; TEXT)&quot;; public KDataBase() &#123; super(KApplication.getContext(), DATABASE_NAME, null, 1); &#125; @Override public void onCreate(SQLiteDatabase db) &#123; db.execSQL(SQL_CREATE_COMMENT_TABLE); &#125; @Override public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) &#123;// String sql = &quot;alter table &quot; + TABLE_COMMENT + &quot; add column info text&quot;;// db.execSQL(sql); &#125;&#125;这里很有必要说一下，在首次使用数据库时，其会执行onCreate()方法，而onUpgrade()方法只有在更改onCreate()中的version参数时才会执行。数据库的版本对我们进行数据库的升级很重要。####当version=1时创建了一个table_name为Table1的表。version=2我们需要在表中添加一个字段或者新增一张表（假设为Table2）。version=3时我们依然是新增一张表。（假设为Table3）####那么onUpgrade()中就需要好好设计。我们注意到在onUpgrade()中返回了oldVersion和newVersion，起初我并不清楚其这样设计的意义。但是如果我们得数据库版本到了version=3的时候，我们就会知道oldVersion的作用了。下面我们详细分析：当我们数据库的version=3时，而使用version=1/version=2的用户依然存在。完全新用户，执行onCreate()方法，创建最新的数据库及表，没有什么问题。version=1的用户，此时apk升级后执行onUpgrade()方法，而这时，通过对比oldVersion我们知道，version=1的用户需要创建两个表，即Table2，Table3。version=2的用户，其只需要创建一张表就够了，我们同样可以根据其oldViersion去选择执行哪一段代码。不容忽视，不容小觑，这就是oldVersion3、创建好了数据库类之后，我们还需要一个帮助类，来完成数据的存储，更新，删除等一列列操作。1234567891011121314151617181920public class KDataBaseHelper &#123; private static KDataBaseHelper sKDataBaseHelper; private SQLiteDatabase mSQLiteDatabase; private KDataBase mKDataBase; public static KDataBaseHelper form() &#123; synchronized (KDataBaseHelper.class) &#123; if (sKDataBaseHelper == null) &#123; sKDataBaseHelper = new KDataBaseHelper(); &#125; &#125; return sKDataBaseHelper; &#125; public KDataBaseHelper() &#123; mKDataBase = new KDataBase(); &#125;&#125;数据插入12345678910111213public void insertComment(CommentBean commentBean) &#123; mSQLiteDatabase = getSQLDataBase(); ContentValues contentValues = new ContentValues(); contentValues.put(FeedEntry.FeedEntryColumn.KEY_NAME, commentBean.name); contentValues.put(FeedEntry.FeedEntryColumn.KEY_AVATAR, commentBean.avatar); contentValues.put(FeedEntry.FeedEntryColumn.KEY_CONTENT, commentBean.content); contentValues.put(FeedEntry.FeedEntryColumn.KEY_REPLY, commentBean.replay); contentValues.put(FeedEntry.FeedEntryColumn.KEY_REPLY_CONTENT, commentBean.reply_content); contentValues.put(FeedEntry.FeedEntryColumn.KEY_TIME, commentBean.time); contentValues.put(FeedEntry.FeedEntryColumn.KEY_INFO, commentBean.info); mSQLiteDatabase.insert(FeedEntry.FeedEntryColumn.TABLE_NAME, null, contentValues); close(null); &#125;数据更新（此处描述的是更新对应_id值等于id的那一行数据的time的值，如果一次想更新多行数据，则循环即可。想要更新哪些值，就使用ContentValues对象put哪些值）1234567public void updataCommentData(CommentBean commentBean, String id) &#123; mSQLiteDatabase = getSQLDataBase(); ContentValues contentValues = new ContentValues(); contentValues.put(FeedEntry.FeedEntryColumn.KEY_TIME, commentBean.time); mSQLiteDatabase.update(FeedEntry.FeedEntryColumn.TABLE_NAME, contentValues, &quot;_id=?&quot;, new String[]&#123;id&#125;); close(null); &#125;分页获取数据（curPage：当前页，从0开始计算；limit：每一页的数量）12345678910111213141516171819202122232425262728public List&lt;CommentBean&gt; getCommentListLimit(int curPage, int limit) &#123; String startPosition = String.valueOf(curPage * limit); List&lt;CommentBean&gt; commentBeanList = new ArrayList&lt;&gt;(); mSQLiteDatabase = getSQLDataBase(); if (mSQLiteDatabase != null) &#123; Cursor cursor = mSQLiteDatabase.query(FeedEntry.FeedEntryColumn.TABLE_NAME, new String[]&#123;FeedEntry.FeedEntryColumn._ID, FeedEntry.FeedEntryColumn.KEY_NAME, FeedEntry.FeedEntryColumn.KEY_AVATAR, FeedEntry.FeedEntryColumn.KEY_CONTENT, FeedEntry.FeedEntryColumn.KEY_REPLY, FeedEntry.FeedEntryColumn.KEY_REPLY_CONTENT, FeedEntry.FeedEntryColumn.KEY_TIME, FeedEntry.FeedEntryColumn.KEY_INFO&#125;, null, null, null, null, &quot;time DESC&quot;, startPosition + &quot;,&quot; + limit); while (cursor.moveToNext()) &#123; CommentBean commentBean = new CommentBean(); commentBean._id = cursor.getInt(cursor.getColumnIndex(FeedEntry.FeedEntryColumn._ID)); commentBean.name = cursor.getString(cursor.getColumnIndex(FeedEntry.FeedEntryColumn.KEY_NAME)); commentBean.avatar = cursor.getString(cursor.getColumnIndex(FeedEntry.FeedEntryColumn.KEY_AVATAR)); commentBean.content = cursor.getString(cursor.getColumnIndex(FeedEntry.FeedEntryColumn.KEY_CONTENT)); commentBean.replay = cursor.getInt(cursor.getColumnIndex(FeedEntry.FeedEntryColumn.KEY_REPLY)); commentBean.reply_content = cursor.getString(cursor.getColumnIndex(FeedEntry.FeedEntryColumn.KEY_REPLY_CONTENT)); commentBean.time = cursor.getString(cursor.getColumnIndex(FeedEntry.FeedEntryColumn.KEY_TIME)); commentBean.info = cursor.getString(cursor.getColumnIndex(FeedEntry.FeedEntryColumn.KEY_INFO)); commentBeanList.add(commentBean); &#125; close(cursor); &#125; return commentBeanList; &#125;删除数据库所有数据12345public void deleteAllComment() &#123; mSQLiteDatabase = getSQLDataBase(); mSQLiteDatabase.delete(FeedEntry.FeedEntryColumn.TABLE_NAME, null, null); close(null);&#125;获取数据库所有记录数123456789public int getCommentCount() &#123; mSQLiteDatabase = getSQLDataBase(); Cursor cursor = mSQLiteDatabase.rawQuery(&quot;select count(*) from &quot; + FeedEntry.FeedEntryColumn.TABLE_NAME, null); //cursor.moveToFirst()将cursor移动到第一条数据 cursor.moveToFirst(); int count = cursor.getInt(0); close(cursor); return count;&#125;关闭数据库及Cursor12345678private void close(Cursor cursor) &#123; if (cursor != null) &#123; cursor.close(); &#125; if (mSQLiteDatabase != null) &#123; mSQLiteDatabase.close(); &#125;&#125;]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>SQLite</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android自定义View在XML中映射错误]]></title>
    <url>%2F2016%2F08%2F18%2FAndroid%E8%87%AA%E5%AE%9A%E4%B9%89View%E5%9C%A8XML%E4%B8%AD%E6%98%A0%E5%B0%84%E9%94%99%E8%AF%AF%2F</url>
    <content type="text"><![CDATA[Android开发中我们经常会遇到自定义View地址映射错误的情况，现将遇到的情况做下总结：12//Android Studio的异常信息Error inflating class1、直接像下面这样，包名所对应的地址错误：在XML中我们地址是com.kcrason.kcircle.widget.HaoRecyclerView，而在实际的项目包名中可能为com.kcrason.kcircle.HaoRecyclerView，从而导致异常信息。123456&lt;com.kcrason.kcircle.widget.HaoRecyclerView android:id=&quot;@+id/rv_list&quot; android:listDivider=&quot;@color/gray&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt;&lt;/com.kcrason.kcircle.widget.HaoRecyclerView&gt;2、包含include标签的XML，且include中的View中含有错误的自定义View的地址，如下面所示，include标签中的include_view有错误，一般最容易让人忽略。12345678&lt;include layout=&quot;@layout/include_view&quot;&gt;&lt;/include&gt;&lt;com.kcrason.kcircle.HaoRecyclerView android:id=&quot;@+id/rv_list&quot; android:listDivider=&quot;@color/gray&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt;&lt;/com.kcrason.kcircle.HaoRecyclerView&gt;3、在Android系统进行XML映射时出现错误，一般来说，即自定义View的初始化操作有问题。通常我们在自定义View时都是构建一个 init() 方法进行一些初始化操作，而正是这些操作造成了一个隐患。因为如果在解析XML中的自定义View不成功时，或者说在这一过程出现了异常时，所抛出的异常信息依然是 Error inflating class ，这是一个非常隐蔽的错误，一般而言，我们不通过断点调试，很难发现到底出了什么问题。PS:我们在构建自定义View时设置View的背景颜色-1234567private void init()&#123; //此处省略 ... setBackground(context.getDrawable(R.color.white)); //此处省略 ...&#125;乍一看好像没啥问题，确实，这段代码在Android 5.0及以上的系统上跑没有任何问题，但是在Android 5.0以下就会直接抛出上面的异常信息。首先 setBackground() 只在API 16及以上才支持，同时 context.getDrawable() 更是LOLLIPOP才支持的方法。而就目前而言，Android studio自定推荐的最低项目版本都是在API 15，结果可想而知。这样写就不再有问题，虽然会提示我们该方法已经过期，但是没关系。当然你也可以通过版本判断，不同版本下使用不同的方法，从而解决这一问题。1setBackgroundDrawable(context.getResources().getDrawable(R.color.white));当然，这里所讲的并不是为了说明版本的适配问题，而是为了更清楚的阐述关于自定义View所造成的一些问题。4、自定义View时，构造方法有问题。这个一般很少出现。5、自定义View为内部类时，需要声明为static才能inflate。由于没有遇到过，这里引用http://blog.csdn.net/soliuyong/article/details/6773059 的博客。PS:关于自定义组件，还需要注意的一点是，如果时内部类，这个类就不能作为layout中的节点的名称，而必须用view作为节点名，然后加入一个class属性，值为该内部类的引用，比如launcher中又下面这样一个例子：123456789101112131415&lt;view class=&quot;com.android.launcher2.AllApps2D$HomeButton&quot; android:id=&quot;@+id/all_apps_2d_home&quot; android:tag=&quot;all_apps_2d_home&quot; android:src=&quot;@drawable/home_button&quot; android:background=&quot;#FF000000&quot; android:layout_centerHorizontal=&quot;true&quot; android:layout_alignParentBottom=&quot;true&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;@dimen/button_bar_height&quot; android:nextFocusUp=&quot;@+id/all_apps_2d_grid&quot; android:nextFocusDown=&quot;@null&quot; android:nextFocusLeft=&quot;@null&quot; android:nextFocusRight=&quot;@null&quot; /&gt;]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Xml</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[List分组请求数据]]></title>
    <url>%2F2016%2F08%2F17%2FList%E5%88%86%E7%BB%84%E8%AF%B7%E6%B1%82%E6%95%B0%E6%8D%AE%2F</url>
    <content type="text"><![CDATA[现在有这样一种需求，假如有一个List，List中存放未知数量的字符串代码，例如：“000007.SZ”，我们希望通过List中的字符代码来获取相对应得股票当前价信息，而当前接口一次最多接受100个股票代码的请求，那么我们如何对List中的所有股票代码的数据请求完成，并无差错的将所有的股票的当前价信息一一保存并对应呢？1、首先我们得对List中的股票代码进行分组，每100个为一组，确定相分组的结果：12345678910private int getGroupNumber() &#123; int listSize = list.size(); int group; if (listSize % 100 == 0) &#123; group = listSize / 100; &#125; else &#123; group = listSize / 100 + 1; &#125; return group;&#125;2、将group返回之后，我们使用循环获取各组的股票代码信息并组成新的String，以便获取相对应股票的当前价。12345678910111213//分组获取股票代码集并请求数据private void getPriceAndupDown() &#123; int group = getGroupNumber(); for (int i = 0; i &lt; group; i++) &#123; String codes; if (i * 100 + 99 &lt; list.size()) &#123; codes = getCode(i * 100, (i * 100) + 99); &#125; else &#123; codes = getCode(i * 100, list.size()); &#125; initRealDatas(i * 100, codes); &#125;&#125;12345678910111213//根据索引获取股票代码集private String getCode(int start, int end) &#123; String codes = &quot;&quot;; for (int i = start; i &lt; end; i++) &#123; String code = list.get(i).Zqdm; if (code.subSequence(0, 1).equals(&quot;6&quot;)) &#123; codes += code + &quot;.SS,&quot;; &#125; else &#123; codes += code + &quot;.SZ,&quot;; &#125; &#125; return codes.substring(0, codes.length() - 1);&#125;3、在进行真实的价格请求时应注意List的对应关系。12345678910private void parseRealDatas(int start, String codes) &#123; for (int i = start; i &lt; codes.split(&quot;,&quot;).length; i++) &#123; //解析数据，此处省略 ... if (i &lt; list.size()) &#123; //price由上面数据解析而来 list.get(i).price = price; &#125; &#125;&#125;4、最后进行数据刷新就可以了，一般来说我们数据都是放在ListView/RecycleView中展示的，那么问题来了，在进行分组请求时，由于网络等不确定性因素，我们什么时候进行数据的刷新 notifyDataSetChanged() 操作呢？当然，从某种程度上来讲，我们不管其是否分组，只要数据获取成功就进行刷新操作，这样并没有什么不妥。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>List</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图片选择KSelectImages]]></title>
    <url>%2F2016%2F07%2F10%2F%E5%9B%BE%E7%89%87%E9%80%89%E6%8B%A9KSelectImages%2F</url>
    <content type="text"><![CDATA[通常android中展示大量图片的时候，容易出现OOM，这个图片框架包括除了有效的解决了图片的OOM问题，还提供了一些人性化的功能。先上图：项目中所用的知识点都是一些常用的，因此就不做过多的解释，相信只要做过几个月Android开发的人都能看懂。源码地址：KSelectImages(图片选择器)]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>图片选择控件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jsoup解析HTML基础用法]]></title>
    <url>%2F2016%2F06%2F28%2FJsoup%E8%A7%A3%E6%9E%90HTML%E5%9F%BA%E7%A1%80%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[Jsoup可以解析网络和本地HTML，常用一般为通过网址解析网页，解析网页可以通过get和post方法获取网页内容。#####解析本地HTML：12String html = &quot;&lt;html&gt;&lt;head&gt;&lt;title&gt;First parse&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Parsed HTML into a doc.&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&quot;;Document document = Jsoup.parse(html);当然，即便你提供的HTML格式不完整，对Jsoup而言，并不是什么问题。#####获取网页HTML：使用get方法12345try &#123; Document document = Jsoup.connect(&quot;http://www.jianshu.com/&quot;).get(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;使用post方法123456789try &#123; //使用post方法请求网页时，其data()方法支持Map传参，同时也可以添加userAgent(用户认证)以及cookie Document document = Jsoup.connect(&quot;http://www.jianshu.com/&quot;) .data(&quot;key&quot;, &quot;value&quot;) .timeout(5000) .post(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;注意：以上两个方法都需要在异步线程中进行。#####Jsoup中一些方法的应用：常用方法select()通过此方法可以查询用id或者class标志的HTML标签，如果是id，select方法中的参数传#id（例：select(#content)），如果是class，则为 标签名.class名（例：select(div.content)）getElementById()获取HTML文档中指定id的Element，HTML文档中Id的定义是唯一的，因此通过此方法获取的是一个唯一的元素。1Element element = getElementById(&quot;content&quot;);getElementsByTag()获取HTML文档中指定标签名的所有元素，得到的以一个Elements集合。1Elements elements = getElementsByTag(&quot;div&quot;);getElementsByClass()获取HTML文档中指定class名的所有元素1Elements elements = getElementsByClass(&quot;content&quot;);getElementsByAttribute()/attr()获去指定属性名的所以Element，例如获取HTML文档下的所有图片链接123456List&lt;String&gt; imageUrls = new ArrayList&lt;&gt;();Elements elements = document.getElementsByAttribute(&quot;data-src&quot;);for (Element element : elements) &#123; String imageUrl = element.select(&quot;img&quot;).first().attr(&quot;data-src&quot;); imageUrls.add(imageUrl);&#125;first()很多时候我们通过getElemetnts…()方法获取的为一个Element集合，这时候我们就可以通过first()方法获取其第一个Element。1Element element = document.select(&quot;div.content&quot;).first();text()如果我们需要获取具体标签下的文本内容就可以使用text()方法，例如我们需要获取div标签class名为content下的h1标签中的内容1String text = document.select(&quot;div.content&quot;).first().getElementsByTag(&quot;h1&quot;).first().text();其它更多用法详见Jsoup官网：https://jsoup.org/]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Jsoup</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown基础用法]]></title>
    <url>%2F2016%2F06%2F28%2FMarkdown%E5%9F%BA%E7%A1%80%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[标题用法:#一级标题##二级标题###三级标题####四级标题#####五级标题######六级标题有序列表：1.方式一2.方式二3.方式三无序列表：第一条第二条第三条链接：http://www.jianshu.com图片:这是一个引用：如果你没有我这是粗体和斜体的用法：粗体 斜体这是标准的分割线：添加代码：12345@Overridepublic boolean onCreateOptionsMenu(Menu menu) &#123; getMenuInflater().inflate(R.menu.memu_particular, menu); return true;&#125;]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android解码Base64图片]]></title>
    <url>%2F2016%2F06%2F27%2FAndroid%E8%A7%A3%E7%A0%81Base64%E5%9B%BE%E7%89%87%2F</url>
    <content type="text"><![CDATA[最近项目中HTML的图片都进行了改变，通常img标签的src返回的是图片路径，而由于后台人员的改变，现在img标签的src返回的是一串Base64格式的编码。具体如下图：因为之前使用webview显示网页时，做了对图片的预览功能，而加载图片也是直接取img标签中src的图片链接去显示图片，后台更改后，就导致了图片无法正常预览出来。这就需要用到Base64对string的解码。具体代码：12345678910public Bitmap stringToBitmap(String string) &#123; Bitmap bitmap = null; try &#123; byte[] bitmapArray = Base64.decode(string.split(&quot;,&quot;)[1], Base64.DEFAULT); bitmap = BitmapFactory.decodeByteArray(bitmapArray, 0, bitmapArray.length); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return bitmap;&#125;注意:编码后的图片会有” data:image/*;base64, “标识，在进行解码时我们需要去掉这一部分，否则会导致解码失败。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Base64</tag>
      </tags>
  </entry>
</search>
